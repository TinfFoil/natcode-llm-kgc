text: Specifically , by leveraging the merits of the deep Long Short-Term Memory ( LSTM ) subnetwork , the proposed model automatically captures the complex long-range temporal dynamics , which naturally avoids the typical sliding window design and thus ensures high computational efficiency .
result: triple_list: [["deep Long Short-Term Memory ( LSTM ) subnetwork", "Part_of", "model"], ["complex long-range temporal dynamics", "Used_for", "model"], ["sliding window design", "Compare", "complex long-range temporal dynamics"], ["computational efficiency", "Evaluate_for", "sliding window design"]]
pred: [('deep Long Short-Term Memory ( LSTM ) subnetwork', 'Part_of', 'model'), ('complex long-range temporal dynamics', 'Used_for', 'model'), ('sliding window design', 'Compare', 'complex long-range temporal dynamics'), ('computational efficiency', 'Evaluate_for', 'sliding window design')]
trues: [['deep Long Short-Term Memory ( LSTM ) subnetwork', 'Used_for', 'model'], ['long-range temporal dynamics', 'Feature_of', 'model']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.0, 0.0, 0]
text: For non-LR grammars the time-complexity of our parser is cubic if the functions that constitute the parser are implemented as memo-functions , i.e. functions that memorize the results of previous invocations .
result: triple_list: [["parser", "Evaluate_for", "functions"]]
pred: [('parser', 'Evaluate_for', 'functions')]
trues: [['time-complexity', 'Evaluate_for', 'parser'], ['parser', 'Used_for', 'non-LR grammars'], ['memo-functions', 'Used_for', 'parser']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.0, 0.0, 0]
text: Towards deep analysis of compositional classes of paraphrases , we have examined a class-oriented framework for collecting paraphrase examples , in which sentential paraphrases are collected for each paraphrase class separately by means of automatic candidate generation and manual judgement .
result: triple_list: [["class-oriented framework", "Used_for", "paraphrase examples"]]
pred: [('class-oriented framework', 'Used_for', 'paraphrase examples')]
trues: [['class-oriented framework', 'Used_for', 'compositional classes of paraphrases'], ['class-oriented framework', 'Used_for', 'paraphrase examples'], ['automatic candidate generation', 'Used_for', 'sentential paraphrases'], ['automatic candidate generation', 'Conjunction', 'manual judgement'], ['manual judgement', 'Used_for', 'sentential paraphrases']]
metrics_sample: [1.0, 0.2, 0.33333333333333337]
metrics_current: [0.16666666666666666, 0.1, 0.125]
text: We have applied it to real scenes that include transparent objects and recovered the shapes of the objects with high accuracy .
result: triple_list: [["it", "Used_for", "real scenes"]]
pred: [('it', 'Used_for', 'real scenes')]
trues: [['it', 'Used_for', 'real scenes'], ['it', 'Used_for', 'shapes of the objects'], ['transparent objects', 'Part_of', 'real scenes'], ['accuracy', 'Evaluate_for', 'shapes of the objects']]
metrics_sample: [1.0, 0.25, 0.4]
metrics_current: [0.2857142857142857, 0.14285714285714285, 0.19047619047619047]
text: Our system incorporates a linguistic parser/generator for LFG , a transfer component for parse reduction operating on packed parse forests , and a maximum-entropy model for stochastic output selection .
result: triple_list: [["LFG", "Part_of", "transfer component for parse reduction"], ["packed parse forests", "Used_for", "transfer component for parse reduction"], ["maximum-entropy model", "Used_for", "stochastic output selection"]]
pred: [('LFG', 'Part_of', 'transfer component for parse reduction'), ('packed parse forests', 'Used_for', 'transfer component for parse reduction'), ('maximum-entropy model', 'Used_for', 'stochastic output selection')]
trues: [['linguistic parser/generator', 'Part_of', 'system'], ['linguistic parser/generator', 'Used_for', 'LFG'], ['linguistic parser/generator', 'Conjunction', 'transfer component'], ['transfer component', 'Part_of', 'system'], ['transfer component', 'Used_for', 'parse reduction'], ['transfer component', 'Conjunction', 'maximum-entropy model'], ['packed parse forests', 'Used_for', 'parse reduction'], ['maximum-entropy model', 'Part_of', 'system'], ['maximum-entropy model', 'Used_for', 'stochastic output selection']]
metrics_sample: [0.3333333333333333, 0.1111111111111111, 0.16666666666666666]
metrics_current: [0.3, 0.13043478260869565, 0.18181818181818182]
text: A language learning experiment showed that assessors can differentiate native from non-native language essays in less than 100 words .
result: triple_list: [["language learning experiment", "Used_for", "assessors"]]
pred: [('language learning experiment', 'Used_for', 'assessors')]
trues: [['language learning', 'Evaluate_for', 'assessors']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.2727272727272727, 0.125, 0.17142857142857143]
text: Furthermore , we propose the use of standard parser evaluation methods for automatically evaluating the summarization quality of sentence condensation systems .
result: The candidate relations for this text are:
Used_for
Evaluate_for
The candidate entities for this text are:
parser evaluation methods
summarization quality of sentence condensation systems
summarization quality of sentence condensation systems
parser evaluation methods

triple_list: [["parser evaluation methods", "Used_for", "summarization quality of sentence condensation systems"], ["summarization quality of sentence condensation systems", "Evaluate_for", "parser evaluation methods"]]
pred: [('parser evaluation methods', 'Used_for', 'summarization quality of sentence condensation systems'), ('summarization quality of sentence condensation systems', 'Evaluate_for', 'parser evaluation methods')]
trues: [['parser evaluation methods', 'Evaluate_for', 'summarization quality'], ['summarization quality', 'Evaluate_for', 'sentence condensation systems']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.23076923076923078, 0.11538461538461539, 0.15384615384615388]
text: A random modulation scheme produces near-Bernoulli statistics even for highly correlated inputs .
result: triple_list: [["Bernoulli statistics", "Evaluate_for", "modulation scheme"]]
pred: [('Bernoulli statistics', 'Evaluate_for', 'modulation scheme')]
trues: [['random modulation scheme', 'Used_for', 'near-Bernoulli statistics'], ['highly correlated inputs', 'Used_for', 'random modulation scheme']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.21428571428571427, 0.10714285714285714, 0.14285714285714285]
text: This formalism is both elementary and powerful enough to strongly simulate many grammar formalisms , such as rewriting systems , dependency grammars , TAG , HPSG and LFG .
result: triple_list: [["grammar formalisms", "Hyponym_of", "rewriting systems"], ["dependency grammars", "Conjunction", "rewriting systems"], ["TAG", "Conjunction", "dependency grammars"], ["TAG", "Hyponym_of", "grammar formalisms"], ["dependency grammars", "Conjunction", "grammar formalisms"], ["HPSG", "Conjunction", "dependency grammars"], ["HPSG", "Hyponym_of", "grammar formalisms"], ["TAG", "Conjunction", "HPSG"], ["TAG", "Hyponym_of", "LFG"], ["HPSG", "Conjunction", "LFG"], ["HPSG", "Hyponym_of", "grammar formalisms"], ["LFG", "Conjunction", "grammar formalisms"]]
pred: [('grammar formalisms', 'Hyponym_of', 'rewriting systems'), ('dependency grammars', 'Conjunction', 'rewriting systems'), ('TAG', 'Conjunction', 'dependency grammars'), ('TAG', 'Hyponym_of', 'grammar formalisms'), ('dependency grammars', 'Conjunction', 'grammar formalisms'), ('HPSG', 'Conjunction', 'dependency grammars'), ('HPSG', 'Hyponym_of', 'grammar formalisms'), ('TAG', 'Conjunction', 'HPSG'), ('TAG', 'Hyponym_of', 'LFG'), ('HPSG', 'Conjunction', 'LFG'), ('HPSG', 'Hyponym_of', 'grammar formalisms'), ('LFG', 'Conjunction', 'grammar formalisms')]
trues: [['formalism', 'Used_for', 'grammar formalisms'], ['rewriting systems', 'Hyponym_of', 'grammar formalisms'], ['rewriting systems', 'Conjunction', 'dependency grammars'], ['dependency grammars', 'Hyponym_of', 'grammar formalisms'], ['dependency grammars', 'Conjunction', 'TAG'], ['TAG', 'Hyponym_of', 'grammar formalisms'], ['TAG', 'Conjunction', 'HPSG'], ['HPSG', 'Hyponym_of', 'grammar formalisms'], ['HPSG', 'Conjunction', 'LFG'], ['LFG', 'Hyponym_of', 'grammar formalisms']]
metrics_sample: [0.36363636363636365, 0.4, 0.380952380952381]
metrics_current: [0.28, 0.18421052631578946, 0.2222222222222222]
text: To associate a sequence of the Fujisaki-model parameters with a text input based on statistical learning , this paper proposes extending this model to a context-dependent one .
result: triple_list: [["Fujisaki-model parameters", "Conjunction", "text input"], ["statistical learning", "Used_for", "text input"]]
pred: [('Fujisaki-model parameters', 'Conjunction', 'text input'), ('statistical learning', 'Used_for', 'text input')]
trues: [['text input', 'Used_for', 'Fujisaki-model parameters'], ['statistical learning', 'Used_for', 'Fujisaki-model parameters']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.25925925925925924, 0.175, 0.208955223880597]
text: Labeled data is replaced by a few hand-crafted rules that encode basic syntactic knowledge .
result: triple_list: [["Labeled data", "Replaced_by", "rules"], ["hand-crafted rules", "Used_for", "syntactic knowledge"]]
pred: [('Labeled data', 'Replaced_by', 'rules'), ('hand-crafted rules', 'Used_for', 'syntactic knowledge')]
trues: [['hand-crafted rules', 'Used_for', 'syntactic knowledge']]
metrics_sample: [0.5, 1.0, 0.6666666666666666]
metrics_current: [0.27586206896551724, 0.1951219512195122, 0.2285714285714286]
text: This paper presents a novel representation for three-dimensional objects in terms of affine-invariant image patches and their spatial relationships .
result: The candidate relations for this text are:
Used_for
Used_for
The candidate entities for this text are:
affine-invariant image patches
three-dimensional objects
affine-invariant image patches
spatial relationships

triple_list: [["affine-invariant image patches", "Used_for", "three-dimensional objects"], ["affine-invariant image patches", "Used_for", "spatial relationships"]]
pred: [('affine-invariant image patches', 'Used_for', 'three-dimensional objects'), ('affine-invariant image patches', 'Used_for', 'spatial relationships')]
trues: [['representation', 'Used_for', 'three-dimensional objects'], ['affine-invariant image patches', 'Feature_of', 'three-dimensional objects'], ['spatial relationships', 'Feature_of', 'affine-invariant image patches']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.25806451612903225, 0.18181818181818182, 0.21333333333333335]
text: This paper presents a phrase-based statistical machine translation method , based on non-contiguous phrases , i.e. phrases with gaps .
result: triple_list: [["phrase-based statistical machine translation method", "Used_for", "non-contiguous phrases"]]
pred: [('phrase-based statistical machine translation method', 'Used_for', 'non-contiguous phrases')]
trues: [['non-contiguous phrases', 'Used_for', 'phrase-based statistical machine translation method']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.25, 0.17777777777777778, 0.20779220779220778]
text: In this paper We experimentally evaluate a trainable sentence planner for a spoken dialogue system by eliciting subjective human judgments .
result: The candidate relations for this text are:
Used_for
Used_for
The candidate entities for this text are:
spoken dialogue system
trainable sentence planner
elicitation of subjective human judgments
spoken dialogue system

triple_list: [["spoken dialogue system", "Used_for", "trainable sentence planner"], ["elicitation of subjective human judgments", "Used_for", "spoken dialogue system"]]
pred: [('spoken dialogue system', 'Used_for', 'trainable sentence planner'), ('elicitation of subjective human judgments', 'Used_for', 'spoken dialogue system')]
trues: [['trainable sentence planner', 'Used_for', 'spoken dialogue system'], ['subjective human judgments', 'Evaluate_for', 'trainable sentence planner']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.23529411764705882, 0.1702127659574468, 0.19753086419753088]
text: We suggest a new goal and evaluation criterion for word similarity measures .
result: triple_list: [["goal", "Conjunction", "evaluation criterion"], ["goal", "Evaluate_for", "word similarity measures"], ["evaluation criterion", "Evaluate_for", "word similarity measures"]]
pred: [('goal', 'Conjunction', 'evaluation criterion'), ('goal', 'Evaluate_for', 'word similarity measures'), ('evaluation criterion', 'Evaluate_for', 'word similarity measures')]
trues: [['evaluation criterion', 'Used_for', 'word similarity measures']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.21621621621621623, 0.16666666666666666, 0.18823529411764706]
text: Such a triangulation provides a piecewise-linear interpolant useful for light field super-resolution .
result: triple_list: [["triangulation", "Used_for", "piecewise-linear interpolant"]]
pred: [('triangulation', 'Used_for', 'piecewise-linear interpolant')]
trues: [['triangulation', 'Used_for', 'piecewise-linear interpolant'], ['piecewise-linear interpolant', 'Used_for', 'light field super-resolution']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.23684210526315788, 0.18, 0.20454545454545453]
text: Criteria for anaphora resolution within sentence boundaries rephrase major concepts from GB 's binding theory , while those for text-level anaphora incorporate an adapted version of a Grosz-Sidner-style focus model .
result: triple_list: [["anaphora resolution", "Used_for", "sentence boundaries"], ["rephrase major concepts", "Used_for", "anaphora resolution"], ["GB 's binding theory", "Used_for", "text-level anaphora"], ["Grosz-Sidner-style focus model", "Compare", "adapted version of Grosz-Sidner-style focus model"]]
pred: [('anaphora resolution', 'Used_for', 'sentence boundaries'), ('rephrase major concepts', 'Used_for', 'anaphora resolution'), ("GB 's binding theory", 'Used_for', 'text-level anaphora'), ('Grosz-Sidner-style focus model', 'Compare', 'adapted version of Grosz-Sidner-style focus model')]
trues: [['Criteria', 'Used_for', 'anaphora resolution within sentence boundaries'], ["GB 's binding theory", 'Used_for', 'Criteria'], ['those', 'Used_for', 'text-level anaphora'], ['Grosz-Sidner-style focus model', 'Part_of', 'those']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.21428571428571427, 0.16666666666666666, 0.1875]
text: A statistical translation model is also presented that deals such phrases , as well as a training method based on the maximization of translation accuracy , as measured with the NIST evaluation metric .
result: triple_list: [["statistical translation model", "Used_for", "phrases"]]
pred: [('statistical translation model', 'Used_for', 'phrases')]
trues: [['statistical translation model', 'Used_for', 'phrases'], ['maximization of translation accuracy', 'Used_for', 'training method'], ['NIST evaluation metric', 'Evaluate_for', 'statistical translation model']]
metrics_sample: [1.0, 0.3333333333333333, 0.5]
metrics_current: [0.23255813953488372, 0.17543859649122806, 0.2]
text: Joint matrix triangularization is often used for estimating the joint eigenstructure of a set M of matrices , with applications in signal processing and machine learning .
result: triple_list: [["Joint matrix triangularization", "Used_for", "joint eigenstructure of a set M of matrices"], ["signal processing", "Used_for", "joint eigenstructure of a set M of matrices"], ["signal processing", "Conjunction", "machine learning"], ["machine learning", "Used_for", "joint eigenstructure of a set M of matrices"]]
pred: [('Joint matrix triangularization', 'Used_for', 'joint eigenstructure of a set M of matrices'), ('signal processing', 'Used_for', 'joint eigenstructure of a set M of matrices'), ('signal processing', 'Conjunction', 'machine learning'), ('machine learning', 'Used_for', 'joint eigenstructure of a set M of matrices')]
trues: [['Joint matrix triangularization', 'Used_for', 'joint eigenstructure'], ['joint eigenstructure', 'Used_for', 'signal processing'], ['joint eigenstructure', 'Used_for', 'machine learning'], ['signal processing', 'Conjunction', 'machine learning']]
metrics_sample: [0.25, 0.25, 0.25]
metrics_current: [0.23404255319148937, 0.18032786885245902, 0.20370370370370372]
text: While previous approaches relied on geometric , appearance , or correlation-based information for establishing correspondences between static cameras , they each have well-known limitations and are not extendable to wide-area settings with PTZ cameras .
result: triple_list: [["approaches", "Used_for", "geometric , appearance , or correlation-based information"], ["approaches", "Used_for", "static cameras"], ["limitation", "Compare", "limitations"], ["they", "Hyponym_of", "approaches"]]
pred: [('approaches', 'Used_for', 'geometric , appearance , or correlation-based information'), ('approaches', 'Used_for', 'static cameras'), ('limitation', 'Compare', 'limitations'), ('they', 'Hyponym_of', 'approaches')]
trues: [['geometric , appearance , or correlation-based information', 'Used_for', 'approaches']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.21568627450980393, 0.1774193548387097, 0.19469026548672566]
text: By employing a joint classification and regression optimization objective , this network is capable of automatically localizing the start and end points of actions more accurately .
result: triple_list: [["joint classification and regression optimization objective", "Used_for", "network"]]
pred: [('joint classification and regression optimization objective', 'Used_for', 'network')]
trues: [['joint classification and regression optimization objective', 'Used_for', 'network']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.23076923076923078, 0.19047619047619047, 0.20869565217391306]
text: Thus , our method can be applied with great benefit to language pairs for which only scarce resources are available .
result: triple_list: [["method", "Used_for", "language pairs"]]
pred: [('method', 'Used_for', 'language pairs')]
trues: [['scarce resources', 'Used_for', 'method']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.22641509433962265, 0.1875, 0.20512820512820515]
text: Memo-functions also facilitate a simple way to construct a very compact representation of the parse forest .
result: triple_list: [["Memo-functions", "Used_for", "way of constructing compact representation of the parse forest"]]
pred: [('Memo-functions', 'Used_for', 'way of constructing compact representation of the parse forest')]
trues: [['Memo-functions', 'Used_for', 'parse forest']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.2222222222222222, 0.18461538461538463, 0.20168067226890757]
text: It uses a powerful pattern-matching language to classify grs into frames hierarchically in a way that mirrors inheritance-based lexica .
result: triple_list: [["pattern-matching language", "Used_for", "classifying grs into frames"]]
pred: [('pattern-matching language', 'Used_for', 'classifying grs into frames')]
trues: [['pattern-matching language', 'Used_for', 'It'], ['pattern-matching language', 'Used_for', 'grs']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.21818181818181817, 0.1791044776119403, 0.1967213114754098]
text: Topical blog post retrieval is the task of ranking blog posts with respect to their relevance for a given topic .
result: triple_list: [["Topical blog post retrieval", "Used_for", "task"]]
pred: [('Topical blog post retrieval', 'Used_for', 'task')]
trues: [['Topical blog post retrieval', 'Hyponym_of', 'ranking blog posts'], ['relevance', 'Feature_of', 'blog posts']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.21428571428571427, 0.17391304347826086, 0.19199999999999998]
text: The perception of transparent objects from images is known to be a very hard problem in vision .
result: triple_list: [["images", "Conjunction", "vision"]]
pred: [('images', 'Conjunction', 'vision')]
trues: [['images', 'Used_for', 'perception of transparent objects']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.21052631578947367, 0.17142857142857143, 0.18897637795275588]
text: A generative framework is used for learning a model that captures the relative position of parts within each of the discretized viewpoints .
result: triple_list: [["generative framework", "Used_for", "model"]]
pred: [('generative framework', 'Used_for', 'model')]
trues: [['generative framework', 'Used_for', 'model']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.22413793103448276, 0.18309859154929578, 0.20155038759689925]
text: Recent progress in computer vision has been driven by high-capacity models trained on large datasets .
result: The candidate relations for this text are:
Used_for
The candidate entities for this text are:
computer vision
high-capacity models

triple_list: [["computer vision", "Used_for", "high-capacity models"]]
pred: [('computer vision', 'Used_for', 'high-capacity models')]
trues: [['high-capacity models', 'Used_for', 'computer vision'], ['large datasets', 'Used_for', 'high-capacity models']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.22033898305084745, 0.1780821917808219, 0.19696969696969696]
text: This model mimics the way in which images are processed in the visual pathway , rendering a feasible alternative for the implementation of early vision applications in standard technologies .
result: triple_list: [["model", "Used_for", "images"]]
pred: [('model', 'Used_for', 'images')]
trues: [['visual pathway', 'Used_for', 'images']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.21666666666666667, 0.17567567567567569, 0.1940298507462687]
text: Recent pool models of the inner hair cell synapse do not reproduce the dead time period after an intense stimulus , so we used visual inspection and automatic speech recognition ( ASR ) to investigate an offset adaptation ( OA ) model proposed by Zhang et al. [ 1 ] .
result: triple_list: [["visual inspection", "Used_for", "offset adaptation ( OA ) model"], ["automatic speech recognition ( ASR )", "Used_for", "offset adaptation ( OA ) model"]]
pred: [('visual inspection', 'Used_for', 'offset adaptation ( OA ) model'), ('automatic speech recognition ( ASR )', 'Used_for', 'offset adaptation ( OA ) model')]
trues: [['pool models', 'Used_for', 'inner hair cell synapse'], ['visual inspection', 'Conjunction', 'automatic speech recognition ( ASR )'], ['visual inspection', 'Used_for', 'offset adaptation ( OA ) model'], ['automatic speech recognition ( ASR )', 'Used_for', 'offset adaptation ( OA ) model']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.24193548387096775, 0.19230769230769232, 0.2142857142857143]
text: Human action recognition from well-segmented 3D skeleton data has been intensively studied and attracting an increasing attention .
result: triple_list: [["Human action recognition", "Feature_of", "3D skeleton data"]]
pred: [('Human action recognition', 'Feature_of', '3D skeleton data')]
trues: [['well-segmented 3D skeleton data', 'Used_for', 'Human action recognition']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.23809523809523808, 0.189873417721519, 0.2112676056338028]
text: With the rise of deep archi-tectures , the prime focus has been on object category recognition .
result: triple_list: [["deep archi-tectures", "prime_focus_on", "object category recognition"]]
pred: [('deep archi-tectures', 'prime_focus_on', 'object category recognition')]
trues: [['deep archi-tectures', 'Used_for', 'object category recognition']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.234375, 0.1875, 0.20833333333333334]
text: In contrast , object pose estimation using these approaches has received relatively less attention .
result: triple_list: [["object pose estimation", "Used_for", "approaches"]]
pred: [('object pose estimation', 'Used_for', 'approaches')]
trues: [['approaches', 'Used_for', 'object pose estimation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.23076923076923078, 0.18518518518518517, 0.20547945205479454]
text: The approach is validated with real image data , and with experimental results from a CID/DRAM analog array prototype in 0.5 cents m CMOS .
result: triple_list: [["real image data", "Hyponym_of", "approach"], ["experimental results", "Compare", "CID/DRAM analog array prototype"]]
pred: [('real image data', 'Hyponym_of', 'approach'), ('experimental results', 'Compare', 'CID/DRAM analog array prototype')]
trues: [['real image data', 'Evaluate_for', 'approach']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.22388059701492538, 0.18292682926829268, 0.20134228187919462]
text: Given a new image , detection and classification are achieved by determining the position and viewpoint of the model that maximize recognition scores of the candidate objects .
result: triple_list: [["image", "Used_for", "detection and classification"], ["position", "Used_for", "model"], ["position", "Evaluate_for", "recognition scores"], ["classification", "Evaluate_for", "recognition scores"]]
pred: [('image', 'Used_for', 'detection and classification'), ('position', 'Used_for', 'model'), ('position', 'Evaluate_for', 'recognition scores'), ('classification', 'Evaluate_for', 'recognition scores')]
trues: [['image', 'Used_for', 'detection'], ['image', 'Used_for', 'classification'], ['detection', 'Conjunction', 'classification'], ['position', 'Used_for', 'detection'], ['position', 'Used_for', 'classification'], ['position', 'Conjunction', 'viewpoint'], ['viewpoint', 'Used_for', 'detection'], ['viewpoint', 'Used_for', 'classification']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.2112676056338028, 0.16666666666666666, 0.18633540372670804]
text: Branch and bound strategies have previously attempted to curb this complexity whilst maintaining global optimality .
result: triple_list: [["Branch and bound strategies", "Used_for", "global optimality"]]
pred: [('Branch and bound strategies', 'Used_for', 'global optimality')]
trues: [['Branch and bound strategies', 'Used_for', 'complexity'], ['global optimality', 'Feature_of', 'Branch and bound strategies']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.20833333333333334, 0.16304347826086957, 0.1829268292682927]
text: Therefore , the study presented in this paper may be useful in inspiring new designs of deep models for person re-identification .
result: triple_list: [["designs of deep models", "Used_for", "person re-identification"]]
pred: [('designs of deep models', 'Used_for', 'person re-identification')]
trues: [['deep models', 'Used_for', 'person re-identification']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.2054794520547945, 0.16129032258064516, 0.18072289156626503]
text: We evaluate the proposed methods through several transliteration/backtransliteration experiments for English/Chinese and English/Japanese language pairs .
result: triple_list: [["English/Chinese", "Conjunction", "English/Japanese"], ["transliteration/backtransliteration experiments", "Evaluate_for", "methods"], ["English/Chinese", "Conjunction", "English/Japanese"]]
pred: [('English/Chinese', 'Conjunction', 'English/Japanese'), ('transliteration/backtransliteration experiments', 'Evaluate_for', 'methods'), ('English/Chinese', 'Conjunction', 'English/Japanese')]
trues: [['transliteration/backtransliteration', 'Evaluate_for', 'methods'], ['transliteration/backtransliteration', 'Used_for', 'English/Chinese and English/Japanese language pairs']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.2, 0.15789473684210525, 0.17647058823529413]
text: This paper presents a critical discussion of the various approaches that have been used in the evaluation of Natural Language systems .
result: The candidate relations for this text are:
Used_for
The candidate entities for this text are:
approaches
evaluation of Natural Language systems

triple_list: [["approaches", "Used_for", "evaluation of Natural Language systems"]]
pred: [('approaches', 'Used_for', 'evaluation of Natural Language systems')]
trues: [['approaches', 'Used_for', 'evaluation of Natural Language systems']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.21052631578947367, 0.16666666666666666, 0.186046511627907]
text: It is particularly valuable to empirical MT research .
result: triple_list: [["It", "Evaluate_for", "empirical MT research"]]
pred: [('It', 'Evaluate_for', 'empirical MT research')]
trues: [['It', 'Used_for', 'empirical MT research']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.2077922077922078, 0.16494845360824742, 0.1839080459770115]
text: We then turn to a discussion comparing the linguistic expressiveness of the two formalisms .
result: The candidate relations for this text are:
Compare
The candidate entities for this text are:
linguistic expressiveness
formalisms

triple_list: [["linguistic expressiveness", "Compare", "formalisms"]]
pred: [('linguistic expressiveness', 'Compare', 'formalisms')]
trues: [['linguistic expressiveness', 'Feature_of', 'formalisms']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.20512820512820512, 0.16326530612244897, 0.1818181818181818]
text: This paper presents an unsupervised learning approach to disambiguate various relations between named entities by use of various lexical and syntactic features from the contexts .
result: triple_list: [["unsupervised learning approach", "Used_for", "disambiguation"]]
pred: [('unsupervised learning approach', 'Used_for', 'disambiguation')]
trues: [['unsupervised learning approach', 'Used_for', 'relations between named entities'], ['lexical and syntactic features', 'Used_for', 'unsupervised learning approach']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.20253164556962025, 0.16, 0.1787709497206704]
text: Finally , we show how the estimation of the tensors from point correspondences is achieved through factorization , and discuss the estimation from line correspondences .
result: The candidate relations for this text are:
Used_for
Used_for
Used_for
The candidate entities for this text are:
factorization
estimation of the tensors
point correspondences
tensors
line correspondences
estimation of the tensors

triple_list: [["factorization", "Used_for", "estimation of the tensors"], ["point correspondences", "Used_for", "tensors"], ["line correspondences", "Used_for", "estimation of the tensors"]]
pred: [('factorization', 'Used_for', 'estimation of the tensors'), ('point correspondences', 'Used_for', 'tensors'), ('line correspondences', 'Used_for', 'estimation of the tensors')]
trues: [['point correspondences', 'Used_for', 'estimation of the tensors'], ['factorization', 'Used_for', 'tensors'], ['line correspondences', 'Used_for', 'estimation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1951219512195122, 0.1553398058252427, 0.17297297297297298]
text: FERRET utilizes a novel approach to Q/A known as predictive questioning which attempts to identify the questions ( and answers ) that users need by analyzing how a user interacts with a system while gathering information related to a particular scenario .
result: triple_list: [["approach", "Used_for", "FERRET"], ["predictive questioning", "Used_for", "users"], ["approach", "Used_for", "predictive questioning"]]
pred: [('approach', 'Used_for', 'FERRET'), ('predictive questioning', 'Used_for', 'users'), ('approach', 'Used_for', 'predictive questioning')]
trues: [['approach', 'Used_for', 'FERRET'], ['approach', 'Used_for', 'Q/A']]
metrics_sample: [0.3333333333333333, 0.5, 0.4]
metrics_current: [0.2, 0.1619047619047619, 0.17894736842105263]
text: However , when the object becomes partially or totally occluded , such local tracking is prone to failure , especially when common prediction techniques like the Kalman filter do not provide a good estimate of object parameters in future frames .
result: triple_list: [["object", "Used_for", "local tracking"], ["local tracking", "Used_for", "failure"], ["Kalman filter", "Used_for", "estimate of object parameters in future frames"]]
pred: [('object', 'Used_for', 'local tracking'), ('local tracking', 'Used_for', 'failure'), ('Kalman filter', 'Used_for', 'estimate of object parameters in future frames')]
trues: [['Kalman filter', 'Part_of', 'prediction techniques']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.19318181818181818, 0.16037735849056603, 0.17525773195876287]
text: We present a strong detector based on combining a set of weak detectors .
result: triple_list: [["weak detectors", "Conjunction", "detector"]]
pred: [('weak detectors', 'Conjunction', 'detector')]
trues: [['detectors', 'Used_for', 'detector']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.19101123595505617, 0.1588785046728972, 0.17346938775510204]
text: In this paper we propose a logical formalism , which , among other things , is suitable for representing determiners without forcing a particular interpretation when their meaning is still not clear .
result: triple_list: [["logical formalism", "Used_for", "determiners"]]
pred: [('logical formalism', 'Used_for', 'determiners')]
trues: [['logical formalism', 'Used_for', 'determiners']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.2, 0.16666666666666666, 0.1818181818181818]
text: For example , nucleotides in a DNA sequence , children 's names in a given state and year , and text documents are all commonly modeled with multinomial distributions .
result: triple_list: [["nucleotides", "Conjunction", "children 's names"], ["children 's names", "Conjunction", "text documents"], ["DNA sequence", "Feature_of", "nucleotides"], ["state and year", "Feature_of", "children 's names"], ["state and year", "Hyponym_of", "children 's names"], ["state and year", "Hyponym_of", "text documents"], ["text documents", "Feature_of", "multinomial distributions"]]
pred: [('nucleotides', 'Conjunction', "children 's names"), ("children 's names", 'Conjunction', 'text documents'), ('DNA sequence', 'Feature_of', 'nucleotides'), ('state and year', 'Feature_of', "children 's names"), ('state and year', 'Hyponym_of', "children 's names"), ('state and year', 'Hyponym_of', 'text documents'), ('text documents', 'Feature_of', 'multinomial distributions')]
trues: [['multinomial distributions', 'Used_for', 'nucleotides in a DNA sequence'], ['multinomial distributions', 'Used_for', 'text documents']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.18556701030927836, 0.16363636363636364, 0.17391304347826086]
text: Experiments show that these two strategies are effective in learning robust deep metrics for person re-identification , and accordingly our deep model significantly outperforms the state-of-the-art methods on several benchmarks of person re-identification .
result: triple_list: [["strategies", "Evaluate_for", "learning robust deep metrics for person re-identification"], ["deep model", "Evaluate_for", "person re-identification"], ["benchmarks", "Compare", "state-of-the-art methods"], ["deep model", "Compare", "benchmarks"]]
pred: [('strategies', 'Evaluate_for', 'learning robust deep metrics for person re-identification'), ('deep model', 'Evaluate_for', 'person re-identification'), ('benchmarks', 'Compare', 'state-of-the-art methods'), ('deep model', 'Compare', 'benchmarks')]
trues: [['robust deep metrics', 'Used_for', 'person re-identification'], ['deep model', 'Compare', 'state-of-the-art methods'], ['deep model', 'Used_for', 'person re-identification'], ['state-of-the-art methods', 'Used_for', 'person re-identification']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1782178217821782, 0.15789473684210525, 0.16744186046511628]
text: The purpose of this research is to test the efficacy of applying automated evaluation techniques , originally devised for the evaluation of human language learners , to the output of machine translation ( MT ) systems .
result: triple_list: [["human language learners", "Evaluate_for", "automated evaluation techniques"], ["machine translation ( MT ) systems", "Evaluate_for", "automated evaluation techniques"]]
pred: [('human language learners', 'Evaluate_for', 'automated evaluation techniques'), ('machine translation ( MT ) systems', 'Evaluate_for', 'automated evaluation techniques')]
trues: [['automated evaluation techniques', 'Used_for', 'evaluation of human language learners']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17475728155339806, 0.1565217391304348, 0.1651376146788991]
text: We evaluate across two corpora ( conversational telephone speech and broadcast news speech ) on both human transcriptions and speech recognition output .
result: triple_list: [["corpora", "Conjunction", "human transcriptions"], ["speech recognition output", "Conjunction", "corpora"]]
pred: [('corpora', 'Conjunction', 'human transcriptions'), ('speech recognition output', 'Conjunction', 'corpora')]
trues: [['corpora', 'Evaluate_for', 'human transcriptions'], ['corpora', 'Evaluate_for', 'speech recognition output'], ['conversational telephone speech', 'Hyponym_of', 'corpora'], ['conversational telephone speech', 'Conjunction', 'broadcast news speech'], ['broadcast news speech', 'Hyponym_of', 'corpora'], ['human transcriptions', 'Conjunction', 'speech recognition output']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17142857142857143, 0.1487603305785124, 0.1592920353982301]
text: We describe a hierarchy of loss functions that incorporate different levels of linguistic information from word strings , word-to-word alignments from an MT system , and syntactic structure from parse-trees of source and target language sentences .
result: triple_list: [["hierarchy of loss functions", "Used_for", "linguistic information"], ["word strings", "Conjunction", "word-to-word alignments"], ["word-to-word alignments", "Conjunction", "syntactic structure"], ["word-to-word alignments", "Conjunction", "parse-trees of source and target language sentences"]]
pred: [('hierarchy of loss functions', 'Used_for', 'linguistic information'), ('word strings', 'Conjunction', 'word-to-word alignments'), ('word-to-word alignments', 'Conjunction', 'syntactic structure'), ('word-to-word alignments', 'Conjunction', 'parse-trees of source and target language sentences')]
trues: [['linguistic information', 'Used_for', 'loss functions'], ['word-to-word alignments', 'Used_for', 'loss functions'], ['word-to-word alignments', 'Part_of', 'MT system'], ['syntactic structure', 'Used_for', 'loss functions'], ['parse-trees', 'Part_of', 'syntactic structure']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1651376146788991, 0.14285714285714285, 0.15319148936170213]
text: Based on this , MINPRAN uses random sampling to search for the t and the number of inliers to the t that are least likely to have occurred randomly .
result: triple_list: [["random sampling", "Used_for", "MINPRAN"]]
pred: [('random sampling', 'Used_for', 'MINPRAN')]
trues: [['random sampling', 'Used_for', 'MINPRAN']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.17272727272727273, 0.14960629921259844, 0.16033755274261605]
text: Second , based on the information resulting from the dictionary lookup stage , a set of rules is applied to the segmented strings in order to identify NE items .
result: triple_list: [["rules", "Used_for", "NE items"]]
pred: [('rules', 'Used_for', 'NE items')]
trues: [['dictionary lookup stage', 'Used_for', 'rules'], ['rules', 'Used_for', 'NE items']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.18018018018018017, 0.15503875968992248, 0.16666666666666666]
text: We propose a convex problem to incorporate side information in robust PCA and show that the low rank matrix can be exactly recovered via the proposed method under certain conditions .
result: triple_list: [["convex problem", "Used_for", "side information"], ["side information", "Conjunction", "robust PCA"], ["low rank matrix", "Used_for", "method"]]
pred: [('convex problem', 'Used_for', 'side information'), ('side information', 'Conjunction', 'robust PCA'), ('low rank matrix', 'Used_for', 'method')]
trues: [['convex problem', 'Used_for', 'side information'], ['side information', 'Part_of', 'robust PCA'], ['method', 'Used_for', 'low rank matrix']]
metrics_sample: [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]
metrics_current: [0.18421052631578946, 0.1590909090909091, 0.17073170731707316]
text: OA improved phase locking in the auditory nerve ( AN ) and raised ASR accuracy for features derived from AN fibers ( ANFs ) .
result: triple_list: [["OA", "Evaluate_for", "auditory nerve ( AN )"], ["OA", "Evaluate_for", "ASR accuracy"], ["ANFs", "Used_for", "features"]]
pred: [('OA', 'Evaluate_for', 'auditory nerve ( AN )'), ('OA', 'Evaluate_for', 'ASR accuracy'), ('ANFs', 'Used_for', 'features')]
trues: [['OA', 'Used_for', 'phase locking in the auditory nerve ( AN )'], ['OA', 'Used_for', 'features'], ['ASR accuracy', 'Evaluate_for', 'features'], ['AN fibers ( ANFs )', 'Used_for', 'features']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1794871794871795, 0.15441176470588236, 0.1660079051383399]
text: We also introduce a novel classification method based on PER which leverages part of speech information of the words contributing to the word matches and non-matches in the sentence .
result: triple_list: [["classification method", "Used_for", "PER"]]
pred: [('classification method', 'Used_for', 'PER')]
trues: [['PER', 'Used_for', 'classification method'], ['PER', 'Used_for', 'part of speech information'], ['part of speech information', 'Used_for', 'word matches and non-matches']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17796610169491525, 0.1510791366906475, 0.16342412451361865]
text: The proposed detectors are able to capture large-scale structures and distinctive textured patterns , and exhibit strong invariance to rotation , illumination variation , and blur .
result: triple_list: [["rotation", "Used_for", "invariance"], ["illumination variation", "Used_for", "invariance"], ["blur", "Used_for", "invariance"]]
pred: [('rotation', 'Used_for', 'invariance'), ('illumination variation', 'Used_for', 'invariance'), ('blur', 'Used_for', 'invariance')]
trues: [['detectors', 'Used_for', 'large-scale structures'], ['detectors', 'Used_for', 'distinctive textured patterns'], ['detectors', 'Used_for', 'rotation'], ['detectors', 'Used_for', 'illumination variation'], ['detectors', 'Used_for', 'blur'], ['large-scale structures', 'Conjunction', 'distinctive textured patterns'], ['rotation', 'Conjunction', 'illumination variation'], ['illumination variation', 'Conjunction', 'blur']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17355371900826447, 0.14285714285714285, 0.15671641791044774]
text: There are four language pairs currently supported by GLOSSER : English-Bulgarian , English-Estonian , English-Hungarian and French-Dutch .
result: triple_list: [["English-Bulgarian", "Conjunction", "English-Estonian"], ["English-Estonian", "Conjunction", "English-Hungarian"], ["English-Hungarian", "Conjunction", "French-Dutch"]]
pred: [('English-Bulgarian', 'Conjunction', 'English-Estonian'), ('English-Estonian', 'Conjunction', 'English-Hungarian'), ('English-Hungarian', 'Conjunction', 'French-Dutch')]
trues: [['language pairs', 'Used_for', 'GLOSSER'], ['English-Bulgarian', 'Hyponym_of', 'language pairs'], ['English-Bulgarian', 'Conjunction', 'English-Estonian'], ['English-Estonian', 'Hyponym_of', 'language pairs'], ['English-Estonian', 'Conjunction', 'English-Hungarian'], ['English-Hungarian', 'Hyponym_of', 'language pairs'], ['English-Hungarian', 'Conjunction', 'French-Dutch'], ['French-Dutch', 'Hyponym_of', 'language pairs']]
metrics_sample: [1.0, 0.375, 0.5454545454545454]
metrics_current: [0.1935483870967742, 0.15483870967741936, 0.17204301075268819]
text: In order to build robust automatic abstracting systems , there is a need for better training resources than are currently available .
result: triple_list: [["training resources", "Used_for", "better training resources"]]
pred: [('training resources', 'Used_for', 'better training resources')]
trues: [['training resources', 'Used_for', 'automatic abstracting systems']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.192, 0.15384615384615385, 0.1708185053380783]
text: Compared to the exhaustive procedure that thus far is the state-of-the-art for cascade evaluation , the proposed method requires fewer evaluations of the classifier functions , thereby speeding up the search .
result: triple_list: [["classifier functions", "Evaluate_for", "method"], ["method", "Compare", "exhaustive procedure"]]
pred: [('classifier functions', 'Evaluate_for', 'method'), ('method', 'Compare', 'exhaustive procedure')]
trues: [['exhaustive procedure', 'Used_for', 'cascade evaluation'], ['exhaustive procedure', 'Compare', 'method'], ['method', 'Used_for', 'search']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1889763779527559, 0.1509433962264151, 0.16783216783216784]
text: Our study reveals that the proposed method not only reduces an extensive system development effort but also improves the transliteration accuracy significantly .
result: triple_list: [["method", "Used_for", "system development effort"], ["transliteration accuracy", "Compare", "method"]]
pred: [('method', 'Used_for', 'system development effort'), ('transliteration accuracy', 'Compare', 'method')]
trues: [['transliteration accuracy', 'Evaluate_for', 'method']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.18604651162790697, 0.15, 0.16608996539792387]
text: To improve topical blog post retrieval we incorporate textual credibility indicators in the retrieval process .
result: triple_list: [["textual credibility indicators", "Feature_of", "retrieval process"]]
pred: [('textual credibility indicators', 'Feature_of', 'retrieval process')]
trues: [['textual credibility indicators', 'Used_for', 'topical blog post retrieval'], ['textual credibility indicators', 'Part_of', 'retrieval process']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.18461538461538463, 0.14814814814814814, 0.1643835616438356]
text: The experimental results show that the proposed histogram-based interest point detectors perform particularly well for the tasks of matching textured scenes under blur and illumination changes , in terms of repeatability and distinctiveness .
result: triple_list: [["histogram-based interest point detectors", "Used_for", "matching textured scenes"]]
pred: [('histogram-based interest point detectors', 'Used_for', 'matching textured scenes')]
trues: [['histogram-based interest point detectors', 'Used_for', 'matching textured scenes'], ['repeatability', 'Evaluate_for', 'histogram-based interest point detectors'], ['repeatability', 'Conjunction', 'distinctiveness'], ['distinctiveness', 'Evaluate_for', 'histogram-based interest point detectors']]
metrics_sample: [1.0, 0.25, 0.4]
metrics_current: [0.19083969465648856, 0.15060240963855423, 0.16835016835016836]
text: This model was shown to be more appropriate for blind separation of natural speech signals .
result: triple_list: [["model", "Evaluate_for", "blind separation of natural speech signals"]]
pred: [('model', 'Evaluate_for', 'blind separation of natural speech signals')]
trues: [['model', 'Used_for', 'blind separation of natural speech signals .']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1893939393939394, 0.1497005988023952, 0.1672240802675585]
text: In addition , we improve the learning by a metric weight constraint , so that the learned metric has a better generalization ability .
result: triple_list: [["learning", "Used_for", "metric weight constraint"]]
pred: [('learning', 'Used_for', 'metric weight constraint')]
trues: [['metric weight constraint', 'Used_for', 'learning'], ['generalization ability', 'Feature_of', 'learned metric']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.18796992481203006, 0.14792899408284024, 0.16556291390728475]
text: Our method has two major components : a ) a pattern extraction scheme for efficiently harvesting patterns of given size and shape from expert game records and b ) a Bayesian learning algorithm ( in two variants ) that learns a distribution over the values of a move given a board position based on the local pattern context .
result: triple_list: [["pattern extraction scheme", "Used_for", "patterns of given size and shape"], ["expert game records", "Used_for", "pattern extraction scheme"], ["Bayesian learning algorithm", "Used_for", "distribution over the values of a move"], ["expert game records", "Used_for", "Bayesian learning algorithm"], ["distribution over the values of a move", "Feature_of", "board position"], ["local pattern context", "Used_for", "Bayesian learning algorithm"]]
pred: [('pattern extraction scheme', 'Used_for', 'patterns of given size and shape'), ('expert game records', 'Used_for', 'pattern extraction scheme'), ('Bayesian learning algorithm', 'Used_for', 'distribution over the values of a move'), ('expert game records', 'Used_for', 'Bayesian learning algorithm'), ('distribution over the values of a move', 'Feature_of', 'board position'), ('local pattern context', 'Used_for', 'Bayesian learning algorithm')]
trues: [['pattern extraction scheme', 'Part_of', 'method'], ['pattern extraction scheme', 'Conjunction', 'Bayesian learning algorithm'], ['Bayesian learning algorithm', 'Part_of', 'method']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17985611510791366, 0.14534883720930233, 0.1607717041800643]
text: Our study reveals that the syntactic structure features embedded in a parse tree are very effective for relation extraction and these features can be well captured by the convolution tree kernel .
result: triple_list: [["syntactic structure features", "Hyponym_of", "parse tree"], ["parse tree", "Used_for", "relation extraction"], ["syntactic structure features", "Used_for", "features"], ["convolution tree kernel", "Compare", "features"]]
pred: [('syntactic structure features', 'Hyponym_of', 'parse tree'), ('parse tree', 'Used_for', 'relation extraction'), ('syntactic structure features', 'Used_for', 'features'), ('convolution tree kernel', 'Compare', 'features')]
trues: [['syntactic structure features', 'Feature_of', 'parse tree'], ['syntactic structure features', 'Used_for', 'relation extraction'], ['convolution tree kernel', 'Used_for', 'features']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17482517482517482, 0.14285714285714285, 0.1572327044025157]
text: Another problem with determiners is their inherent ambiguity .
result: triple_list: [["problem", "Hyponym_of", "determiners"]]
pred: [('problem', 'Hyponym_of', 'determiners')]
trues: [['ambiguity', 'Feature_of', 'determiners']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1736111111111111, 0.14204545454545456, 0.15625]
text: We present an application of ambiguity packing and stochastic disambiguation techniques for Lexical-Functional Grammars ( LFG ) to the domain of sentence condensation .
result: triple_list: [["ambiguity packing and stochastic disambiguation techniques", "Used_for", "Lexical-Functional Grammars ( LFG )"], ["sentence condensation", "Used_for", "Lexical-Functional Grammars ( LFG )"]]
pred: [('ambiguity packing and stochastic disambiguation techniques', 'Used_for', 'Lexical-Functional Grammars ( LFG )'), ('sentence condensation', 'Used_for', 'Lexical-Functional Grammars ( LFG )')]
trues: [['ambiguity packing and stochastic disambiguation techniques', 'Used_for', 'Lexical-Functional Grammars ( LFG )'], ['ambiguity packing and stochastic disambiguation techniques', 'Used_for', 'sentence condensation']]
metrics_sample: [0.5, 0.5, 0.5]
metrics_current: [0.1780821917808219, 0.14606741573033707, 0.16049382716049382]
text: This paper presents necessary and sufficient conditions for the use of demonstrative expressions in English and discusses implications for current discourse processing algorithms .
result: triple_list: [["demonstrative expressions", "Conjunction", "discourse processing algorithms"]]
pred: [('demonstrative expressions', 'Conjunction', 'discourse processing algorithms')]
trues: [['demonstrative expressions', 'Feature_of', 'English'], ['implications', 'Used_for', 'discourse processing algorithms']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17687074829931973, 0.14444444444444443, 0.15902140672782872]
text: Contrary to most of the existing mixture of viewpoints models , our model establishes explicit correspondences of parts across different viewpoints of the object class .
result: triple_list: [["model", "Used_for", "object class"]]
pred: [('model', 'Used_for', 'object class')]
trues: [['model', 'Compare', 'mixture of viewpoints models']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17567567567567569, 0.143646408839779, 0.1580547112462006]
text: Unlike other techniques that handle large outlier percentages , MINPRAN does not rely on a known error bound for the good data .
result: triple_list: [["error bound", "Used_for", "good data"], ["MINPRAN", "Compare", "techniques"]]
pred: [('error bound', 'Used_for', 'good data'), ('MINPRAN', 'Compare', 'techniques')]
trues: [['techniques', 'Used_for', 'large outlier percentages'], ['techniques', 'Compare', 'MINPRAN']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.17333333333333334, 0.14207650273224043, 0.15615615615615613]
text: We present a new part-of-speech tagger that demonstrates the following ideas : ( i ) explicit use of both preceding and following tag contexts via a dependency network representation , ( ii ) broad use of lexical features , including jointly conditioning on multiple consecutive words , ( iii ) effective use of priors in conditional loglinear models , and ( iv ) fine-grained modeling of unknown word features .
result: triple_list: [["part-of-speech tagger", "Used_for", "ideas"], ["dependency network representation", "Used_for", "explicit use of both preceding and following tag contexts"], ["dependency network representation", "Conjunction", "lexical features"], ["jointly conditioning on multiple consecutive words", "Used_for", "lexical features"], ["priors", "Conjunction", "conditional loglinear models"], ["priors", "Used_for", "conditional loglinear models"], ["unknown word features", "Conjunction", "fine-grained modeling of unknown word features"]]
pred: [('part-of-speech tagger', 'Used_for', 'ideas'), ('dependency network representation', 'Used_for', 'explicit use of both preceding and following tag contexts'), ('dependency network representation', 'Conjunction', 'lexical features'), ('jointly conditioning on multiple consecutive words', 'Used_for', 'lexical features'), ('priors', 'Conjunction', 'conditional loglinear models'), ('priors', 'Used_for', 'conditional loglinear models'), ('unknown word features', 'Conjunction', 'fine-grained modeling of unknown word features')]
trues: [['tag contexts', 'Used_for', 'part-of-speech tagger'], ['dependency network representation', 'Used_for', 'tag contexts'], ['lexical features', 'Used_for', 'part-of-speech tagger'], ['priors in conditional loglinear models', 'Used_for', 'part-of-speech tagger'], ['fine-grained modeling of unknown word features', 'Used_for', 'part-of-speech tagger']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16560509554140126, 0.13829787234042554, 0.1507246376811594]
text: Our main result is a first-order upper bound on the distance between any approximate joint triangularizer of the matrices in M ' and any exact joint triangularizer of the matrices in M .
result: triple_list: [["approximate joint triangularizer of the matrices in M ' and exact joint triangularizer of the matrices in M", "first-order upper bound", "distance"]]
pred: [("approximate joint triangularizer of the matrices in M ' and exact joint triangularizer of the matrices in M", 'first-order upper bound', 'distance')]
trues: [['approximate joint triangularizer', 'Conjunction', 'exact joint triangularizer']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16455696202531644, 0.13756613756613756, 0.14985590778097982]
text: The unique properties of tree-adjoining grammars ( TAG ) present a challenge for the application of TAGs beyond the limited confines of syntax , for instance , to the task of semantic interpretation or automatic translation of natural language .
result: triple_list: [["tree-adjoining grammars ( TAG )", "Feature_of", "semantic interpretation"], ["tree-adjoining grammars ( TAG )", "Feature_of", "automatic translation of natural language"]]
pred: [('tree-adjoining grammars ( TAG )', 'Feature_of', 'semantic interpretation'), ('tree-adjoining grammars ( TAG )', 'Feature_of', 'automatic translation of natural language')]
trues: [['TAGs', 'Used_for', 'semantic interpretation'], ['TAGs', 'Used_for', 'automatic translation of natural language'], ['semantic interpretation', 'Conjunction', 'automatic translation of natural language']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1625, 0.13541666666666666, 0.1477272727272727]
text: Our combination methods rely on predominant senses which are derived automatically from raw text .
result: triple_list: [["raw text", "Part_of", "predominant senses"]]
pred: [('raw text', 'Part_of', 'predominant senses')]
trues: [['predominant senses', 'Used_for', 'combination methods'], ['raw text', 'Used_for', 'predominant senses']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16149068322981366, 0.13402061855670103, 0.14647887323943662]
text: In this paper , we explore geometric structures of 3D lines in ray space for improving light field triangulation and stereo matching .
result: The candidate relations for this text are:
Used_for
Used_for
The candidate entities for this text are:
geometric structures of 3D lines
ray space
geometric structures of 3D lines
light field triangulation and stereo matching

triple_list: [["geometric structures of 3D lines", "Used_for", "ray space"], ["geometric structures of 3D lines", "Used_for", "light field triangulation and stereo matching"]]
pred: [('geometric structures of 3D lines', 'Used_for', 'ray space'), ('geometric structures of 3D lines', 'Used_for', 'light field triangulation and stereo matching')]
trues: [['geometric structures of 3D lines', 'Used_for', 'light field triangulation'], ['geometric structures of 3D lines', 'Used_for', 'stereo matching'], ['ray space', 'Feature_of', 'geometric structures of 3D lines'], ['light field triangulation', 'Conjunction', 'stereo matching']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15950920245398773, 0.13131313131313133, 0.14404432132963987]
text: In this paper , we discuss language model adaptation methods given a word list and a raw corpus .
result: The candidate relations for this text are:
Used_for
Used_for
Used_for
The candidate entities for this text are:
word list
language model adaptation methods
raw corpus
language model adaptation methods
raw corpus
word list

triple_list: [["word list", "Used_for", "language model adaptation methods"], ["raw corpus", "Used_for", "language model adaptation methods"], ["raw corpus", "Used_for", "word list"]]
pred: [('word list', 'Used_for', 'language model adaptation methods'), ('raw corpus', 'Used_for', 'language model adaptation methods'), ('raw corpus', 'Used_for', 'word list')]
trues: [['word list', 'Used_for', 'language model adaptation methods'], ['word list', 'Conjunction', 'raw corpus'], ['raw corpus', 'Used_for', 'language model adaptation methods']]
metrics_sample: [0.6666666666666666, 0.6666666666666666, 0.6666666666666666]
metrics_current: [0.1686746987951807, 0.13930348258706468, 0.1525885558583106]
text: In particular there are three areas of novelty : ( i ) we show how a photometric model of image formation can be combined with a statistical model of generic face appearance variation , learnt offline , to generalize in the presence of extreme illumination changes ; ( ii ) we use the smoothness of geodesically local appearance manifold structure and a robust same-identity likelihood to achieve invariance to unseen head poses ; and ( iii ) we introduce an accurate video sequence '' reillumination '' algorithm to achieve robustness to face motion patterns in video .
result: triple_list: [["photometric model of image formation", "Conjunction", "statistical model of generic face appearance variation"], ["statistical model of generic face appearance variation", "Used_for", "generalization"], ["smoothness of geodesically local appearance manifold structure", "Feature_of", "robust same-identity likelihood"], ["robust same-identity likelihood", "Feature_of", "robustness to unseen head poses"], ["video sequence '' reillumination '' algorithm", "Used_for", "robustness to face motion patterns in video"]]
pred: [('photometric model of image formation', 'Conjunction', 'statistical model of generic face appearance variation'), ('statistical model of generic face appearance variation', 'Used_for', 'generalization'), ('smoothness of geodesically local appearance manifold structure', 'Feature_of', 'robust same-identity likelihood'), ('robust same-identity likelihood', 'Feature_of', 'robustness to unseen head poses'), ("video sequence '' reillumination '' algorithm", 'Used_for', 'robustness to face motion patterns in video')]
trues: [['photometric model', 'Used_for', 'image formation'], ['photometric model', 'Conjunction', 'statistical model'], ['statistical model', 'Used_for', 'generic face appearance variation'], ['statistical model', 'Used_for', 'extreme illumination changes'], ['smoothness', 'Feature_of', 'geodesically local appearance manifold structure'], ['geodesically local appearance manifold structure', 'Conjunction', 'robust same-identity likelihood'], ['robustness', 'Evaluate_for', "video sequence '' reillumination '' algorithm"], ['face motion patterns', 'Feature_of', 'robustness'], ['face motion patterns', 'Part_of', 'video']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16374269005847952, 0.13333333333333333, 0.14698162729658792]
text: A purely functional implementation of LR-parsers is given , together with a simple correctness proof .
result: triple_list: [["purely functional implementation of LR-parsers", "Used_for", "correctness proof"]]
pred: [('purely functional implementation of LR-parsers', 'Used_for', 'correctness proof')]
trues: [['correctness proof', 'Conjunction', 'LR-parsers']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16279069767441862, 0.13270142180094788, 0.14621409921671022]
text: Our core motivation is that minimizing a weighted rank loss is a natural criterion for many problems in computer vision such as person re-identification .
result: triple_list: [["weighted rank loss", "Used_for", "computer vision problems"], ["person re-identification", "Hyponym_of", "computer vision problems"]]
pred: [('weighted rank loss', 'Used_for', 'computer vision problems'), ('person re-identification', 'Hyponym_of', 'computer vision problems')]
trues: [['weighted rank loss', 'Used_for', 'computer vision'], ['weighted rank loss', 'Used_for', 'person re-identification'], ['person re-identification', 'Hyponym_of', 'computer vision']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16091954022988506, 0.1308411214953271, 0.14432989690721648]
text: We rigorously establish the correctness of the methodology and show by experimentation using LSH that it is competitive in practice with available alternatives .
result: triple_list: [["methodology", "Evaluate_for", "it"], ["it", "Compare", "alternatives"]]
pred: [('methodology', 'Evaluate_for', 'it'), ('it', 'Compare', 'alternatives')]
trues: [['it', 'Compare', 'alternatives']]
metrics_sample: [0.5, 1.0, 0.6666666666666666]
metrics_current: [0.16477272727272727, 0.13488372093023257, 0.1483375959079284]
text: An extension of our method to space-time interest point detection for action classification is also presented .
result: triple_list: [["method", "Used_for", "space-time interest point detection for action classification"]]
pred: [('method', 'Used_for', 'space-time interest point detection for action classification')]
trues: [['method', 'Used_for', 'space-time interest point detection'], ['space-time interest point detection', 'Used_for', 'action classification']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1638418079096045, 0.1336405529953917, 0.14720812182741116]
text: We propose a novel probabilistic framework for learning visual models of 3D object categories by combining appearance information and geometric constraints .
result: The candidate relations for this text are:
Used_for
Used_for
Conjunction
The candidate entities for this text are:
probabilistic framework
visual models
appearance information
geometric constraints
appearance information
geometric constraints

triple_list: [["probabilistic framework", "Used_for", "visual models"], ["appearance information", "Used_for", "geometric constraints"], ["appearance information", "Conjunction", "geometric constraints"]]
pred: [('probabilistic framework', 'Used_for', 'visual models'), ('appearance information', 'Used_for', 'geometric constraints'), ('appearance information', 'Conjunction', 'geometric constraints')]
trues: [['probabilistic framework', 'Used_for', 'visual models of 3D object categories'], ['appearance information', 'Used_for', 'probabilistic framework'], ['appearance information', 'Conjunction', 'geometric constraints'], ['geometric constraints', 'Used_for', 'probabilistic framework']]
metrics_sample: [0.3333333333333333, 0.25, 0.28571428571428575]
metrics_current: [0.16666666666666666, 0.13574660633484162, 0.14962593516209474]
text: The fact that Turkish is an agglutinating free word order language presents a challenge for language theories .
result: triple_list: [["Turkish", "Feature_of", "agglutinating free word order language"]]
pred: [('Turkish', 'Feature_of', 'agglutinating free word order language')]
trues: [['Turkish', 'Hyponym_of', 'agglutinating free word order language']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16574585635359115, 0.13513513513513514, 0.14888337468982632]
text: The strong description and modeling properties of differential features make them useful tools that can be efficiently used as constraints for 3 -- D reconstruction .
result: triple_list: [["differential features", "Used_for", "tools"], ["constraints", "Used_for", "3 -- D reconstruction"]]
pred: [('differential features', 'Used_for', 'tools'), ('constraints', 'Used_for', '3 -- D reconstruction')]
trues: [['them', 'Used_for', '3 -- D reconstruction']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16393442622950818, 0.13452914798206278, 0.14778325123152708]
text: Subpixel accuracy is achieved by considering several zero-crossings defined by the difference between pairs of unstructured patterns .
result: triple_list: [["zero-crossings", "Conjunction", "unstructured patterns"]]
pred: [('zero-crossings', 'Conjunction', 'unstructured patterns')]
trues: [['zero-crossings', 'Used_for', 'Subpixel accuracy']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16304347826086957, 0.13392857142857142, 0.14705882352941177]
text: A domain independent model is proposed for the automated interpretation of nominal compounds in English .
result: triple_list: [["domain independent model", "Used_for", "automated interpretation of nominal compounds in English"]]
pred: [('domain independent model', 'Used_for', 'automated interpretation of nominal compounds in English')]
trues: [['domain independent model', 'Used_for', 'automated interpretation of nominal compounds'], ['English', 'Feature_of', 'nominal compounds']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16216216216216217, 0.13274336283185842, 0.14598540145985406]
text: We present a novel approach for automatically acquiring English topic signatures .
result: triple_list: [["approach", "Used_for", "English topic signatures"]]
pred: [('approach', 'Used_for', 'English topic signatures')]
trues: [['approach', 'Used_for', 'automatically acquiring English topic signatures']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16129032258064516, 0.13215859030837004, 0.14527845036319612]
text: These methods diier from previous work in the area in two ways : the use of an action model formalism which is better suited to the needs of a re-active agent , and successful implementation of noise-handling mechanisms .
result: triple_list: [["action model formalism", "Compare", "methods"]]
pred: [('action model formalism', 'Compare', 'methods')]
trues: [['action model formalism', 'Used_for', 'methods'], ['action model formalism', 'Used_for', 're-active agent'], ['noise-handling mechanisms', 'Used_for', 'methods']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16042780748663102, 0.13043478260869565, 0.14388489208633093]
text: The task of machine translation ( MT ) evaluation is closely related to the task of sentence-level semantic equivalence classification .
result: Look at the examples below and then carry out the following indicated task.

Example 1:
text: "The performance of the new MT system is evaluated on several sentence retrieval tasks ."
The candidate relations for this text are:
Evaluate_for
The candidate entities for this text are:
sentence retrieval tasks
MT system

triple_list: [["sentence retrieval tasks", "Evaluate_for", "MT system"]]

Example 2:
text: "The method of performing music performance under such a system is based on the theory of `` dynamic ensembles , '' presented at the BYTE conference in 1978 ."
The candidate relations for this text are:
Hyponym_of
The candidate entities for this text are:
dynamic ensembles
`` dynamic ensembles , ''

triple_list: [["dynamic ensembles", "Hyponym_of", "`` dynamic ensembles , ''"]]

Example 3:
text: "This paper explores the use of Chinese verb arguments to identify translation equivalences ."
The candidate relations for this text are:
Used_for
Used_for
The candidate entities for this text are:
Chinese verb arguments
translation equivalences
Chinese verb arguments
translation

triple_list: [["Chinese verb arguments", "Used_for", "translation equivalences"], ["Chinese verb arguments", "Used_for", "translation"]]


Task: Extract a list of [entity, relation, entity] triples from the text below. Do not produce any more text samples after you finish extracting triples from the text below.
text: "We further introduce a method for automatically training the pruner using very small amounts of training data ."
The candidate relations for this text are:
Used_for
The candidate entities for this text are:
method
pruner

triple_list: [["method", "Used_for", "pruner"]]
pred: [('sentence retrieval tasks', 'Evaluate_for', 'MT system'), ('dynamic ensembles', 'Hyponym_of', "`` dynamic ensembles , ''"), ('Chinese verb arguments', 'Used_for', 'translation equivalences'), ('Chinese verb arguments', 'Used_for', 'translation'), ('method', 'Used_for', 'pruner')]
trues: [['machine translation ( MT ) evaluation', 'Conjunction', 'sentence-level semantic equivalence classification']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15625, 0.12987012987012986, 0.14184397163120568]
text: This paper describes a method for incorporating priming into an incremental probabilistic parser .
result: triple_list: [["priming", "Feature_of", "incremental probabilistic parser"]]
pred: [('priming', 'Feature_of', 'incremental probabilistic parser')]
trues: [['method', 'Used_for', 'priming'], ['priming', 'Used_for', 'incremental probabilistic parser']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15544041450777202, 0.12875536480686695, 0.14084507042253522]
text: Experiments on synthetic and real data show that both our triangulation and LAGC algorithms outperform state-of-the-art solutions in accuracy and visual quality .
result: triple_list: [["synthetic and real data", "Evaluate_for", "our triangulation and LAGC algorithms"], ["accuracy and visual quality", "Compare", "state-of-the-art solutions"]]
pred: [('synthetic and real data', 'Evaluate_for', 'our triangulation and LAGC algorithms'), ('accuracy and visual quality', 'Compare', 'state-of-the-art solutions')]
trues: [['synthetic and real data', 'Evaluate_for', 'triangulation and LAGC algorithms'], ['synthetic and real data', 'Evaluate_for', 'state-of-the-art solutions'], ['triangulation and LAGC algorithms', 'Compare', 'state-of-the-art solutions'], ['accuracy', 'Evaluate_for', 'triangulation and LAGC algorithms'], ['accuracy', 'Evaluate_for', 'state-of-the-art solutions'], ['visual quality', 'Evaluate_for', 'triangulation and LAGC algorithms'], ['visual quality', 'Evaluate_for', 'state-of-the-art solutions']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15384615384615385, 0.125, 0.13793103448275862]
text: Experiments on the PASCAL VOC 2006 dataset show an acceleration of more than 50 % by our method compared to standard cascade evaluation .
result: triple_list: [["PASCAL VOC 2006 dataset", "Evaluate_for", "method"], ["PASCAL VOC 2006 dataset", "Evaluate_for", "cascade evaluation"]]
pred: [('PASCAL VOC 2006 dataset', 'Evaluate_for', 'method'), ('PASCAL VOC 2006 dataset', 'Evaluate_for', 'cascade evaluation')]
trues: [['PASCAL VOC 2006 dataset', 'Evaluate_for', 'method'], ['PASCAL VOC 2006 dataset', 'Evaluate_for', 'cascade evaluation'], ['cascade evaluation', 'Compare', 'method']]
metrics_sample: [1.0, 0.6666666666666666, 0.8]
metrics_current: [0.16243654822335024, 0.13168724279835392, 0.14545454545454548]
text: Language resource quality is crucial in NLP .
result: triple_list: [["Language resource quality", "Part_of", "NLP"]]
pred: [('Language resource quality', 'Part_of', 'NLP')]
trues: [['Language resource quality', 'Feature_of', 'NLP']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16161616161616163, 0.13114754098360656, 0.14479638009049775]
text: In this paper , we study the problem of online action detection from the streaming skeleton data .
result: triple_list: [["online action detection", "Used_for", "streaming skeleton data"]]
pred: [('online action detection', 'Used_for', 'streaming skeleton data')]
trues: [['streaming skeleton data', 'Used_for', 'online action detection']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16080402010050251, 0.1306122448979592, 0.14414414414414414]
text: We explored possible ways to obtain a compact lexicon , consistent with CCG principles , from a treebank which is an order of magnitude smaller than Penn WSJ .
result: triple_list: [["treebank", "Used_for", "compact lexicon"], ["treebank", "Compare", "Penn WSJ"]]
pred: [('treebank', 'Used_for', 'compact lexicon'), ('treebank', 'Compare', 'Penn WSJ')]
trues: [['compact lexicon', 'Part_of', 'treebank'], ['treebank', 'Compare', 'Penn WSJ']]
metrics_sample: [0.5, 0.5, 0.5]
metrics_current: [0.16417910447761194, 0.13360323886639677, 0.14732142857142858]
text: To our knowledge , this is the first a posteriori bound for joint matrix decomposition .
result: triple_list: [["aposteriori bound", "Used_for", "joint matrix decomposition"]]
pred: [('aposteriori bound', 'Used_for', 'joint matrix decomposition')]
trues: [['posteriori bound', 'Used_for', 'joint matrix decomposition']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16336633663366337, 0.13306451612903225, 0.14666666666666667]
text: This phenomenon causes many image processing techniques to fail as they assume the presence of only one layer at each examined site e.g. motion estimation and object recognition .
result: triple_list: [["one layer", "Used_for", "layer"], ["motion estimation", "Used_for", "image processing techniques"], ["object recognition", "Used_for", "image processing techniques"]]
pred: [('one layer', 'Used_for', 'layer'), ('motion estimation', 'Used_for', 'image processing techniques'), ('object recognition', 'Used_for', 'image processing techniques')]
trues: [['motion estimation', 'Conjunction', 'object recognition']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.16097560975609757, 0.13253012048192772, 0.14537444933920707]
text: Learned confidence measures gain increasing importance for outlier removal and quality improvement in stereo vision .
result: The candidate relations for this text are:
Evaluate_for
Conjunction
Evaluate_for
The candidate entities for this text are:
outlier removal
Learned confidence measures
quality improvement
Learned confidence measures
stereo vision
quality improvement

triple_list: [["outlier removal", "Evaluate_for", "Learned confidence measures"], ["quality improvement", "Conjunction", "Learned confidence measures"], ["stereo vision", "Evaluate_for", "quality improvement"]]
pred: [('outlier removal', 'Evaluate_for', 'Learned confidence measures'), ('quality improvement', 'Conjunction', 'Learned confidence measures'), ('stereo vision', 'Evaluate_for', 'quality improvement')]
trues: [['Learned confidence measures', 'Used_for', 'outlier removal'], ['Learned confidence measures', 'Used_for', 'quality improvement'], ['outlier removal', 'Conjunction', 'quality improvement'], ['outlier removal', 'Part_of', 'stereo vision'], ['quality improvement', 'Part_of', 'stereo vision']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15865384615384615, 0.12992125984251968, 0.14285714285714285]
text: In both domains , we found that unsupervised methods can attain accuracies with 400 unlabeled examples comparable to those attained by supervised methods on 50 labeled examples , and that semi-supervised methods can make good use of small amounts of labeled data .
result: triple_list: [["unsupervised methods", "Evaluate_for", "domains"], ["accuracies", "Compare", "supervised methods"], ["accuracies", "Evaluate_for", "unlabeled examples"], ["unsupervised methods", "Used_for", "supervised methods"], ["unlabeled examples", "Conjunction", "labeled examples"], ["semi-supervised methods", "Used_for", "unlabeled examples"]]
pred: [('unsupervised methods', 'Evaluate_for', 'domains'), ('accuracies', 'Compare', 'supervised methods'), ('accuracies', 'Evaluate_for', 'unlabeled examples'), ('unsupervised methods', 'Used_for', 'supervised methods'), ('unlabeled examples', 'Conjunction', 'labeled examples'), ('semi-supervised methods', 'Used_for', 'unlabeled examples')]
trues: [['unsupervised methods', 'Compare', 'supervised methods'], ['accuracies', 'Evaluate_for', 'unsupervised methods'], ['accuracies', 'Evaluate_for', 'supervised methods'], ['unlabeled examples', 'Used_for', 'unsupervised methods'], ['labeled examples', 'Used_for', 'supervised methods'], ['labeled data', 'Used_for', 'semi-supervised methods']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1542056074766355, 0.12692307692307692, 0.13924050632911392]
text: Here we develop an approach for 1 distance that begins with an explicit and exactly distance-preserving embedding of the points into 2 2 .
result: triple_list: [["distance", "Evaluate_for", "approach"]]
pred: [('distance', 'Evaluate_for', 'approach')]
trues: [['approach', 'Used_for', '1 distance']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15348837209302327, 0.12643678160919541, 0.13865546218487396]
text: Coedition of a natural language text and its representation in some interlingual form seems the best and simplest way to share text revision across languages .
result: triple_list: [["natural language text", "Part_of", "interlingual form"]]
pred: [('natural language text', 'Part_of', 'interlingual form')]
trues: [['Coedition', 'Used_for', 'text revision'], ['natural language text', 'Used_for', 'Coedition']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1527777777777778, 0.12547528517110265, 0.13778705636743216]
text: A new algorithm is proposed for novel view generation in one-to-one teleconferencing applications .
result: triple_list: [["algorithm", "Used_for", "one-to-one teleconferencing applications"]]
pred: [('algorithm', 'Used_for', 'one-to-one teleconferencing applications')]
trues: [['algorithm', 'Used_for', 'novel view generation'], ['novel view generation', 'Used_for', 'one-to-one teleconferencing applications']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15207373271889402, 0.12452830188679245, 0.13692946058091288]
text: The objective of this work is to recognize faces using video sequences both for training and recognition input , in a realistic , unconstrained setup in which lighting , pose and user motion pattern have a wide variability and face images are of low resolution .
result: triple_list: [["video sequences", "Used_for", "faces"], ["training and recognition input", "Hyponym_of", "video sequences"], ["lighting", "Evaluate_for", "face recognition"], ["pose", "Evaluate_for", "face recognition"], ["user motion pattern", "Evaluate_for", "face recognition"], ["lighting", "Feature_of", "face images"], ["pose", "Feature_of", "face images"], ["user motion pattern", "Feature_of", "face images"], ["resolution", "Conjunction", "low resolution"]]
pred: [('video sequences', 'Used_for', 'faces'), ('training and recognition input', 'Hyponym_of', 'video sequences'), ('lighting', 'Evaluate_for', 'face recognition'), ('pose', 'Evaluate_for', 'face recognition'), ('user motion pattern', 'Evaluate_for', 'face recognition'), ('lighting', 'Feature_of', 'face images'), ('pose', 'Feature_of', 'face images'), ('user motion pattern', 'Feature_of', 'face images'), ('resolution', 'Conjunction', 'low resolution')]
trues: [['lighting', 'Conjunction', 'pose'], ['pose', 'Conjunction', 'user motion pattern'], ['resolution', 'Feature_of', 'face images']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14601769911504425, 0.12313432835820895, 0.13360323886639677]
text: Relaxations of these properties expose some of the interesting ( and unavoidable ) trade-offs at work in well-studied clustering techniques such as single-linkage , sum-of-pairs , k-means , and k-median .
result: triple_list: [["properties", "Feature_of", "clustering techniques"], ["single-linkage , sum-of-pairs , k-means , and k-median", "Hyponym_of", "clustering techniques"]]
pred: [('properties', 'Feature_of', 'clustering techniques'), ('single-linkage , sum-of-pairs , k-means , and k-median', 'Hyponym_of', 'clustering techniques')]
trues: [['single-linkage', 'Hyponym_of', 'well-studied clustering techniques'], ['single-linkage', 'Conjunction', 'sum-of-pairs'], ['sum-of-pairs', 'Hyponym_of', 'well-studied clustering techniques'], ['sum-of-pairs', 'Conjunction', 'k-means'], ['k-means', 'Hyponym_of', 'well-studied clustering techniques'], ['k-means', 'Conjunction', 'k-median'], ['k-median', 'Hyponym_of', 'well-studied clustering techniques']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14473684210526316, 0.12, 0.13121272365805167]
text: Some of the extracts were expert human translations , others were machine translation outputs .
result: triple_list: [["expert human translations", "Part_of", "extracts"], ["machine translation outputs", "Part_of", "extracts"]]
pred: [('expert human translations', 'Part_of', 'extracts'), ('machine translation outputs', 'Part_of', 'extracts')]
trues: [['machine translation outputs', 'Conjunction', 'expert human translations']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14347826086956522, 0.11956521739130435, 0.13043478260869565]
text: Owing to these variations , the pedestrian data is distributed as highly-curved manifolds in the feature space , despite the current convolutional neural networks ( CNN ) 's capability of feature extraction .
result: triple_list: [["pedestrian data", "Distributed_as", "highly-curved manifolds in the feature space"], ["convolutional neural networks ( CNN )", "Used_for", "feature extraction"]]
pred: [('pedestrian data', 'Distributed_as', 'highly-curved manifolds in the feature space'), ('convolutional neural networks ( CNN )', 'Used_for', 'feature extraction')]
trues: [['highly-curved manifolds', 'Used_for', 'pedestrian data'], ['feature space', 'Feature_of', 'highly-curved manifolds'], ['convolutional neural networks ( CNN )', 'Used_for', 'feature extraction']]
metrics_sample: [0.5, 0.3333333333333333, 0.4]
metrics_current: [0.14655172413793102, 0.12186379928315412, 0.13307240704500978]
text: The results of the experiment show that in most of the cases the cooccurrence statistics indeed reflect the semantic constraints and thus provide a basis for a useful disambiguation tool .
result: triple_list: [["cooccurrence statistics", "Used_for", "disambiguation tool"], ["cooccurrence statistics", "Part_of", "semantic constraints"], ["semantic constraints", "Conjunction", "disambiguation tool"]]
pred: [('cooccurrence statistics', 'Used_for', 'disambiguation tool'), ('cooccurrence statistics', 'Part_of', 'semantic constraints'), ('semantic constraints', 'Conjunction', 'disambiguation tool')]
trues: [['cooccurrence statistics', 'Used_for', 'disambiguation tool']]
metrics_sample: [0.3333333333333333, 1.0, 0.5]
metrics_current: [0.14893617021276595, 0.125, 0.13592233009708737]
text: Our proposed approach builds on recent advances in spectral clustering , image matting , and boundary detection .
result: triple_list: [["approach", "Used_for", "spectral clustering"], ["image matting", "Conjunction", "spectral clustering"], ["image matting", "Used_for", "approach"], ["image matting", "Conjunction", "boundary detection"], ["boundary detection", "Used_for", "approach"]]
pred: [('approach', 'Used_for', 'spectral clustering'), ('image matting', 'Conjunction', 'spectral clustering'), ('image matting', 'Used_for', 'approach'), ('image matting', 'Conjunction', 'boundary detection'), ('boundary detection', 'Used_for', 'approach')]
trues: [['spectral clustering', 'Used_for', 'approach'], ['spectral clustering', 'Conjunction', 'image matting'], ['image matting', 'Used_for', 'approach'], ['image matting', 'Conjunction', 'boundary detection'], ['boundary detection', 'Used_for', 'approach']]
metrics_sample: [0.6, 0.6, 0.6]
metrics_current: [0.15833333333333333, 0.13333333333333333, 0.14476190476190476]
text: This poster paper describes a full scale two-level morphological description ( Karttunen , 1983 ; Koskenniemi , 1983 ) of Turkish word structures .
result: triple_list: [["two-level morphological description ( Karttunen , 1983 ; Koskenniemi , 1983 )", "Used_for", "Turkish word structures"], ["full scale two-level morphological description ( Karttunen , 1983 ; Koskenniemi , 1983 )", "Evaluate_for", "Turkish word structures"]]
pred: [('two-level morphological description ( Karttunen , 1983 ; Koskenniemi , 1983 )', 'Used_for', 'Turkish word structures'), ('full scale two-level morphological description ( Karttunen , 1983 ; Koskenniemi , 1983 )', 'Evaluate_for', 'Turkish word structures')]
trues: [['full scale two-level morphological description', 'Used_for', 'Turkish word structures']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15702479338842976, 0.13286713286713286, 0.14393939393939395]
text: This paper proposes to use a convolution kernel over parse trees to model syntactic structure information for relation extraction .
result: triple_list: [["convolution kernel", "Used_for", "syntactic structure information for relation extraction"]]
pred: [('convolution kernel', 'Used_for', 'syntactic structure information for relation extraction')]
trues: [['convolution kernel over parse trees', 'Used_for', 'syntactic structure information'], ['syntactic structure information', 'Used_for', 'relation extraction']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15637860082304528, 0.13194444444444445, 0.1431261770244821]
text: The objects can be complex in that they may be composed of multiple layers with different refractive indices .
result: triple_list: [["objects", "Part_of", "layers"]]
pred: [('objects', 'Part_of', 'layers')]
trues: [['multiple layers', 'Part_of', 'they'], ['refractive indices', 'Feature_of', 'multiple layers']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1557377049180328, 0.1310344827586207, 0.14232209737827717]
text: We explain this distinction and we show how this model may be applied to the interpretation of compounds in real texts , provided that complementary semantic information are retrieved .
result: triple_list: [["model", "Used_for", "interpretation of compounds in real texts"], ["complementary semantic information", "Used_for", "model"]]
pred: [('model', 'Used_for', 'interpretation of compounds in real texts'), ('complementary semantic information', 'Used_for', 'model')]
trues: [['model', 'Used_for', 'interpretation of compounds']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15447154471544716, 0.13058419243986255, 0.1415270018621974]
text: This has the advantages of efficiency on grammatical input , and robustness in the face of ungrammatical input .
result: triple_list: [["grammatical input", "Evaluate_for", "efficiency"], ["ungrammatical input", "Evaluate_for", "robustness"]]
pred: [('grammatical input', 'Evaluate_for', 'efficiency'), ('ungrammatical input', 'Evaluate_for', 'robustness')]
trues: [['ungrammatical input', 'Feature_of', 'robustness']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1532258064516129, 0.13013698630136986, 0.14074074074074072]
text: We provide a unified account of sentence-level and text-level anaphora within the framework of a dependency-based grammar model .
result: The candidate relations for this text are:
Used_for
Part_of
The candidate entities for this text are:
dependency-based grammar model
unified account of sentence-level and text-level anaphora
dependency-based grammar model
framework

triple_list: [["dependency-based grammar model", "Used_for", "unified account of sentence-level and text-level anaphora"], ["dependency-based grammar model", "Part_of", "framework"]]
pred: [('dependency-based grammar model', 'Used_for', 'unified account of sentence-level and text-level anaphora'), ('dependency-based grammar model', 'Part_of', 'framework')]
trues: [['dependency-based grammar model', 'Used_for', 'sentence-level and text-level anaphora']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.152, 0.1296928327645051, 0.13996316758747698]
text: It models reflection as regions containing two different layers moving over each other .
result: triple_list: [["layers", "Used_for", "reflection"]]
pred: [('layers', 'Used_for', 'reflection')]
trues: [['It', 'Used_for', 'reflection']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15139442231075698, 0.1292517006802721, 0.13944954128440368]
text: We consider the problem of computing the Kullback-Leibler distance , also called the relative entropy , between a probabilistic context-free grammar and a probabilistic finite automaton .
result: The candidate relations for this text are:
Conjunction
Used_for
Used_for
Used_for
The candidate entities for this text are:
Kullback-Leibler distance
relative entropy
probabilistic context-free grammar
Kullback-Leibler distance
probabilistic context-free grammar
relative entropy
probabilistic finite automaton
relative entropy

triple_list: [["Kullback-Leibler distance", "Conjunction", "relative entropy"], ["probabilistic context-free grammar", "Used_for", "Kullback-Leibler distance"], ["probabilistic context-free grammar", "Used_for", "relative entropy"], ["probabilistic finite automaton", "Used_for", "relative entropy"]]
pred: [('Kullback-Leibler distance', 'Conjunction', 'relative entropy'), ('probabilistic context-free grammar', 'Used_for', 'Kullback-Leibler distance'), ('probabilistic context-free grammar', 'Used_for', 'relative entropy'), ('probabilistic finite automaton', 'Used_for', 'relative entropy')]
trues: [['probabilistic context-free grammar', 'Compare', 'probabilistic finite automaton']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14901960784313725, 0.1288135593220339, 0.13818181818181818]
text: This paper describes a novel system for acquiring adjectival subcategorization frames ( scfs ) and associated frequency information from English corpus data .
result: triple_list: [["adjectival subcategorization frames ( scfs )", "Used_for", "system"], ["English corpus data", "Used_for", "frequency information"]]
pred: [('adjectival subcategorization frames ( scfs )', 'Used_for', 'system'), ('English corpus data', 'Used_for', 'frequency information')]
trues: [['system', 'Used_for', 'acquiring adjectival subcategorization frames ( scfs )']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14785992217898833, 0.12837837837837837, 0.13743218806509946]
text: Our approach to the Multi-lingual Evaluation Task ( MET ) for Japanese text is to consider the given task as a morphological analysis problem in Japanese .
result: triple_list: [["Multi-lingual Evaluation Task ( MET )", "Used_for", "approach"]]
pred: [('Multi-lingual Evaluation Task ( MET )', 'Used_for', 'approach')]
trues: [['approach', 'Used_for', 'Multi-lingual Evaluation Task ( MET )'], ['Multi-lingual Evaluation Task ( MET )', 'Used_for', 'Japanese text'], ['morphological analysis problem', 'Used_for', 'task'], ['Japanese', 'Used_for', 'morphological analysis problem']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14728682170542637, 0.12666666666666668, 0.13620071684587814]
text: It is based on a weakly supervised dependency parser that can model speech syntax without relying on any annotated training corpus .
result: triple_list: [["weakly supervised dependency parser", "Used_for", "speech syntax"]]
pred: [('weakly supervised dependency parser', 'Used_for', 'speech syntax')]
trues: [['weakly supervised dependency parser', 'Used_for', 'speech syntax']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.15057915057915058, 0.12956810631229235, 0.1392857142857143]
text: Many of the resources used are derived from data created by human beings out of an NLP context , especially regarding MT and reference translations .
result: triple_list: [["NLP context", "Used_for", "resources"]]
pred: [('NLP context', 'Used_for', 'resources')]
trues: [['MT', 'Hyponym_of', 'NLP'], ['MT', 'Conjunction', 'reference translations'], ['reference translations', 'Hyponym_of', 'NLP']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15, 0.12828947368421054, 0.13829787234042554]
text: Extension to affine projection enables reconstruction without estimating cameras .
result: triple_list: [["affine projection", "Extension", "reconstruction"]]
pred: [('affine projection', 'Extension', 'reconstruction')]
trues: [['affine projection', 'Used_for', 'reconstruction']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14942528735632185, 0.12786885245901639, 0.13780918727915195]
text: On the other hand , the manifold learning methods suggest to use the Euclidean distance in the local range , combining with the graphical relationship between samples , for approximating the geodesic distance .
result: triple_list: [["Euclidean distance", "Conjunction", "graphical relationship between samples"], ["graphical relationship between samples", "Used_for", "geodesic distance"]]
pred: [('Euclidean distance', 'Conjunction', 'graphical relationship between samples'), ('graphical relationship between samples', 'Used_for', 'geodesic distance')]
trues: [['Euclidean distance', 'Used_for', 'manifold learning methods'], ['Euclidean distance', 'Conjunction', 'graphical relationship'], ['Euclidean distance', 'Used_for', 'geodesic distance'], ['local range', 'Feature_of', 'Euclidean distance'], ['graphical relationship', 'Used_for', 'geodesic distance']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1482889733840304, 0.12580645161290321, 0.13612565445026178]
text: Furthermore , this paper presents a novel algorithm for the temporal maintenance of a background model to enhance the rendering of occlusions and reduce temporal artefacts ( flicker ) ; and a cost aggregation algorithm that acts directly on our three-dimensional matching cost space .
result: triple_list: [["algorithm", "Used_for", "temporal maintenance of a background model"], ["occlusions", "Used_for", "temporal maintenance of a background model"], ["temporalartefacts", "Evaluate_for", "temporal maintenance of a background model"], ["flicker", "Evaluate_for", "temporalartefacts"], ["cost aggregation algorithm", "Used_for", "three-dimensional matching cost space"]]
pred: [('algorithm', 'Used_for', 'temporal maintenance of a background model'), ('occlusions', 'Used_for', 'temporal maintenance of a background model'), ('temporalartefacts', 'Evaluate_for', 'temporal maintenance of a background model'), ('flicker', 'Evaluate_for', 'temporalartefacts'), ('cost aggregation algorithm', 'Used_for', 'three-dimensional matching cost space')]
trues: [['algorithm', 'Used_for', 'temporal maintenance of a background model'], ['algorithm', 'Used_for', 'rendering of occlusions'], ['algorithm', 'Used_for', 'temporal artefacts ( flicker )'], ['cost aggregation algorithm', 'Conjunction', 'algorithm'], ['cost aggregation algorithm', 'Used_for', 'three-dimensional matching cost space']]
metrics_sample: [0.4, 0.4, 0.4000000000000001]
metrics_current: [0.15298507462686567, 0.13015873015873017, 0.1406518010291595]
text: We propose a novel step toward the unsupervised seg-mentation of whole objects by combining '' hints '' of partial scene segmentation offered by multiple soft , binary mattes .
result: triple_list: [["soft , binary mattes", "Used_for", "'' hints '' of partial scene segmentation"]]
pred: [('soft , binary mattes', 'Used_for', "'' hints '' of partial scene segmentation")]
trues: [['partial scene segmentation', 'Used_for', 'unsupervised seg-mentation of whole objects'], ['soft , binary mattes', 'Used_for', 'partial scene segmentation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1524163568773234, 0.12933753943217666, 0.13993174061433444]
text: Utterance Verification ( UV ) is a critical function of an Automatic Speech Recognition ( ASR ) System working on real applications where spontaneous speech , out-of-vocabulary ( OOV ) words and acoustic noises are present .
result: triple_list: [["Utterance Verification ( UV )", "Feature_of", "Automatic Speech Recognition ( ASR ) System"], ["out-of-vocabulary ( OOV ) words", "Hyponym_of", "Utterance Verification ( UV )"], ["acoustic noises", "Conjunction", "out-of-vocabulary ( OOV ) words"], ["acoustic noises", "Hyponym_of", "Utterance Verification ( UV )"]]
pred: [('Utterance Verification ( UV )', 'Feature_of', 'Automatic Speech Recognition ( ASR ) System'), ('out-of-vocabulary ( OOV ) words', 'Hyponym_of', 'Utterance Verification ( UV )'), ('acoustic noises', 'Conjunction', 'out-of-vocabulary ( OOV ) words'), ('acoustic noises', 'Hyponym_of', 'Utterance Verification ( UV )')]
trues: [['Utterance Verification ( UV )', 'Hyponym_of', 'Automatic Speech Recognition ( ASR ) System']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15018315018315018, 0.1289308176100629, 0.13874788494077833]
text: Thus , in this paper , we study the problem of robust PCA with side information , where both prior structure and features of entities are exploited for recovery .
result: triple_list: [["prior structure", "Used_for", "robust PCA with side information"], ["features of entities", "Used_for", "robust PCA with side information"], ["prior structure", "Used_for", "features of entities"], ["features of entities", "Used_for", "recovery"]]
pred: [('prior structure', 'Used_for', 'robust PCA with side information'), ('features of entities', 'Used_for', 'robust PCA with side information'), ('prior structure', 'Used_for', 'features of entities'), ('features of entities', 'Used_for', 'recovery')]
trues: [['side information', 'Used_for', 'robust PCA'], ['prior structure', 'Conjunction', 'features of entities'], ['prior structure', 'Used_for', 'recovery'], ['features of entities', 'Used_for', 'recovery']]
metrics_sample: [0.25, 0.25, 0.25]
metrics_current: [0.15162454873646208, 0.13043478260869565, 0.14023372287145242]
text: This reflects contemporary methods for unsupervised object discovery from groups of images , and it allows us to define intuitive evaluation met-rics for our sets of segmentations based on the accurate and parsimonious delineation of scene objects .
result: triple_list: [["methods", "Used_for", "unsupervised object discovery from groups of images"]]
pred: [('methods', 'Used_for', 'unsupervised object discovery from groups of images')]
trues: [['contemporary methods', 'Used_for', 'unsupervised object discovery']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1510791366906475, 0.13003095975232198, 0.13976705490848587]
text: The seven categories of the scheme are based on rhetorical moves of argumentation .
result: triple_list: [["rhetorical moves of argumentation", "Part_of", "categories of the scheme"]]
pred: [('rhetorical moves of argumentation', 'Part_of', 'categories of the scheme')]
trues: [['rhetorical moves of argumentation', 'Used_for', 'scheme']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15053763440860216, 0.12962962962962962, 0.13930348258706468]
text: In spite of over two decades of intense research , illumination and pose invariance remain prohibitively challenging aspects of face recognition for most practical applications .
result: triple_list: [["illumination and pose invariance", "Conjunction", "face recognition"]]
pred: [('illumination and pose invariance', 'Conjunction', 'face recognition')]
trues: [['illumination', 'Conjunction', 'pose invariance'], ['illumination', 'Part_of', 'face recognition'], ['pose invariance', 'Part_of', 'face recognition']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15, 0.12844036697247707, 0.13838550247116968]
text: In this paper , we present our approach for using information extraction annotations to augment document retrieval for distillation .
result: triple_list: [["information extraction annotations", "Used_for", "document retrieval"]]
pred: [('information extraction annotations', 'Used_for', 'document retrieval')]
trues: [['information extraction annotations', 'Used_for', 'document retrieval for distillation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1494661921708185, 0.12804878048780488, 0.13793103448275865]
text: Although hidden Markov models ( HMMs ) provide a suitable generative model for field structured text , general unsupervised HMM learning fails to learn useful structure in either of our domains .
result: triple_list: [["hidden Markov models ( HMMs )", "Used_for", "generative model"], ["generative model", "Used_for", "field structured text"], ["unsupervised HMM learning", "Compare", "general unsupervised HMM learning"], ["structure", "Evaluate_for", "general unsupervised HMM learning"]]
pred: [('hidden Markov models ( HMMs )', 'Used_for', 'generative model'), ('generative model', 'Used_for', 'field structured text'), ('unsupervised HMM learning', 'Compare', 'general unsupervised HMM learning'), ('structure', 'Evaluate_for', 'general unsupervised HMM learning')]
trues: [['hidden Markov models ( HMMs )', 'Used_for', 'generative model'], ['generative model', 'Used_for', 'field structured text']]
metrics_sample: [0.5, 1.0, 0.6666666666666666]
metrics_current: [0.1543859649122807, 0.13333333333333333, 0.14308943089430895]
text: The experimental tests are carried out on the Verbmobil task ( German-English , 8000-word vocabulary ) , which is a limited-domain spoken-language task .
result: triple_list: [["Verbmobil task ( German-English , 8000-word vocabulary )", "Hyponym_of", "limited-domain spoken-language task"]]
pred: [('Verbmobil task ( German-English , 8000-word vocabulary )', 'Hyponym_of', 'limited-domain spoken-language task')]
trues: [['Verbmobil task', 'Hyponym_of', 'limited-domain spoken-language task']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15384615384615385, 0.13293051359516617, 0.1426256077795786]
text: Using the IEMOCAP database , discrete ( categorical ) and continuous ( attribute ) emotional assessments evaluated by the actors and na  ve listeners are compared .
result: triple_list: [["discrete ( categorical ) and continuous ( attribute ) emotional assessments", "Evaluate_for", "IEMOCAP database"], ["actors", "Compare", "na  ve listeners"], ["actors", "Evaluate_for", "discrete ( categorical ) and continuous ( attribute ) emotional assessments"], ["na  ve listeners", "Evaluate_for", "discrete ( categorical ) and continuous ( attribute ) emotional assessments"]]
pred: [('discrete ( categorical ) and continuous ( attribute ) emotional assessments', 'Evaluate_for', 'IEMOCAP database'), ('actors', 'Compare', 'na  ve listeners'), ('actors', 'Evaluate_for', 'discrete ( categorical ) and continuous ( attribute ) emotional assessments'), ('na  ve listeners', 'Evaluate_for', 'discrete ( categorical ) and continuous ( attribute ) emotional assessments')]
trues: [['IEMOCAP database', 'Used_for', 'discrete ( categorical ) and continuous ( attribute ) emotional assessments']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.15172413793103448, 0.13253012048192772, 0.1414790996784566]
text: We describe a fully automatic recognition system based on the proposed method and an extensive evaluation on 171 individuals and over 1300 video sequences with extreme illumination , pose and head motion variation .
result: triple_list: [["recognition system", "Used_for", "method"], ["evaluation", "Used_for", "video sequences"], ["extreme illumination", "Conjunction", "pose and head motion variation"], ["extreme illumination", "Used_for", "video sequences"], ["pose and head motion variation", "Conjunction", "video sequences"]]
pred: [('recognition system', 'Used_for', 'method'), ('evaluation', 'Used_for', 'video sequences'), ('extreme illumination', 'Conjunction', 'pose and head motion variation'), ('extreme illumination', 'Used_for', 'video sequences'), ('pose and head motion variation', 'Conjunction', 'video sequences')]
trues: [['method', 'Used_for', 'fully automatic recognition system'], ['video sequences', 'Evaluate_for', 'fully automatic recognition system'], ['illumination', 'Feature_of', 'video sequences'], ['illumination', 'Conjunction', 'pose'], ['pose', 'Feature_of', 'video sequences'], ['pose', 'Conjunction', 'head motion variation'], ['head motion variation', 'Feature_of', 'video sequences']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14915254237288136, 0.12979351032448377, 0.13880126182965297]
text: On the internal side , liaisons are established between elements of the text and the graph by using broadly available resources such as a LO-English or better a L0-UNL dictionary , a morphosyntactic parser of L0 , and a canonical graph2tree transformation .
result: triple_list: [["internal side", "Used_for", "liaisons"], ["elements of the text", "Conjunction", "graph"], ["LO-English", "Hyponym_of", "L0-UNL dictionary"], ["LO-English", "Conjunction", "L0-UNL dictionary"], ["morphosyntactic parser of L0", "Used_for", "graph2tree transformation"], ["morphosyntactic parser of L0", "Conjunction", "graph2tree transformation"], ["L0-UNL dictionary", "Used_for", "morphosyntactic parser of L0"], ["L0-UNL dictionary", "Used_for", "graph2tree transformation"]]
pred: [('internal side', 'Used_for', 'liaisons'), ('elements of the text', 'Conjunction', 'graph'), ('LO-English', 'Hyponym_of', 'L0-UNL dictionary'), ('LO-English', 'Conjunction', 'L0-UNL dictionary'), ('morphosyntactic parser of L0', 'Used_for', 'graph2tree transformation'), ('morphosyntactic parser of L0', 'Conjunction', 'graph2tree transformation'), ('L0-UNL dictionary', 'Used_for', 'morphosyntactic parser of L0'), ('L0-UNL dictionary', 'Used_for', 'graph2tree transformation')]
trues: [['resources', 'Used_for', 'liaisons'], ['LO-English or better a L0-UNL dictionary', 'Hyponym_of', 'resources'], ['LO-English or better a L0-UNL dictionary', 'Conjunction', 'morphosyntactic parser of L0'], ['morphosyntactic parser of L0', 'Hyponym_of', 'resources'], ['morphosyntactic parser of L0', 'Conjunction', 'canonical graph2tree transformation'], ['canonical graph2tree transformation', 'Hyponym_of', 'resources']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14521452145214522, 0.12753623188405797, 0.13580246913580246]
text: We report experiments conducted on a multilingual corpus to estimate the number of analogies among the sentences that it contains .
result: The candidate relations for this text are:
Evaluate_for
The candidate entities for this text are:
corpus
number of analogies

triple_list: [["corpus", "Evaluate_for", "number of analogies"]]
pred: [('corpus', 'Evaluate_for', 'number of analogies')]
trues: [['multilingual corpus', 'Evaluate_for', 'analogies']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14473684210526316, 0.12716763005780346, 0.13538461538461538]
text: Topic signatures can be useful in a number of Natural Language Processing ( NLP ) applications , such as Word Sense Disambiguation ( WSD ) and Text Summarisation .
result: triple_list: [["Natural Language Processing ( NLP ) applications", "Hyponym_of", "Word Sense Disambiguation ( WSD )"], ["Natural Language Processing ( NLP ) applications", "Conjunction", "Text Summarisation"]]
pred: [('Natural Language Processing ( NLP ) applications', 'Hyponym_of', 'Word Sense Disambiguation ( WSD )'), ('Natural Language Processing ( NLP ) applications', 'Conjunction', 'Text Summarisation')]
trues: [['Topic signatures', 'Used_for', 'Natural Language Processing ( NLP ) applications'], ['Topic signatures', 'Used_for', 'Word Sense Disambiguation ( WSD )'], ['Topic signatures', 'Used_for', 'Text Summarisation'], ['Word Sense Disambiguation ( WSD )', 'Hyponym_of', 'Natural Language Processing ( NLP ) applications'], ['Word Sense Disambiguation ( WSD )', 'Conjunction', 'Text Summarisation'], ['Text Summarisation', 'Hyponym_of', 'Natural Language Processing ( NLP ) applications']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1437908496732026, 0.125, 0.1337386018237082]
text: In this paper , we present our work on the detection of question-answer pairs in an email conversation for the task of email summarization .
result: triple_list: [["email conversation", "Part_of", "detection of question-answer pairs"], ["email summarization", "Used_for", "detection of question-answer pairs"]]
pred: [('email conversation', 'Part_of', 'detection of question-answer pairs'), ('email summarization', 'Used_for', 'detection of question-answer pairs')]
trues: [['detection of question-answer pairs', 'Used_for', 'email summarization'], ['email conversation', 'Used_for', 'detection of question-answer pairs']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14285714285714285, 0.12429378531073447, 0.13293051359516617]
text: Full digital resolution is maintained even with low-resolution analog-to-digital conversion , owing to random statistics in the analog summation of binary products .
result: triple_list: [["low-resolution analog-to-digital conversion", "Feature_of", "random statistics in the analog summation of binary products"]]
pred: [('low-resolution analog-to-digital conversion', 'Feature_of', 'random statistics in the analog summation of binary products')]
trues: [['random statistics', 'Part_of', 'analog summation of binary products']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1423948220064725, 0.12394366197183099, 0.13253012048192772]
text: Hitherto , smooth motion has been encouraged using a trajectory basis , yielding a hard combinatorial problem with time complexity growing exponentially in the number of frames .
result: triple_list: [["smooth motion", "Used_for", "trajectory basis"]]
pred: [('smooth motion', 'Used_for', 'trajectory basis')]
trues: [['trajectory basis', 'Used_for', 'smooth motion'], ['time complexity', 'Evaluate_for', 'hard combinatorial problem']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14193548387096774, 0.12324929971988796, 0.13193403298350823]
text: Overall summarization quality of the proposed system is state-of-the-art , with guaranteed grammaticality of the system output due to the use of a constraint-based parser/generator .
result: triple_list: [["Overall summarization quality", "Used_for", "system"]]
pred: [('Overall summarization quality', 'Used_for', 'system')]
trues: [['summarization quality', 'Evaluate_for', 'system'], ['grammaticality', 'Evaluate_for', 'system'], ['constraint-based parser/generator', 'Used_for', 'system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1414790996784566, 0.12222222222222222, 0.13114754098360656]
text: Our experiments clearly indicate the potential of this dynamic representation for complete cursive handwriting recognition .
result: triple_list: [["dynamic representation", "Used_for", "complete cursive handwriting recognition"]]
pred: [('dynamic representation', 'Used_for', 'complete cursive handwriting recognition')]
trues: [['dynamic representation', 'Used_for', 'cursive handwriting recognition']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14102564102564102, 0.12188365650969529, 0.13075780089153044]
text: A general procedure for the estimation and quantization of these cycloidal motion parameters for arbitrary handwriting is presented .
result: triple_list: [["cycloidal motion parameters", "Used_for", "handwriting"]]
pred: [('cycloidal motion parameters', 'Used_for', 'handwriting')]
trues: [['cycloidal motion parameters', 'Used_for', 'arbitrary handwriting']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14057507987220447, 0.12154696132596685, 0.1303703703703704]
text: A new tool for linguistic annotation of scfs in corpus data is also introduced which can considerably alleviate the process of obtaining training and test data for subcategorization acquisition .
result: triple_list: [["scfs", "Used_for", "linguistic annotation of scfs in corpus data"]]
pred: [('scfs', 'Used_for', 'linguistic annotation of scfs in corpus data')]
trues: [['tool', 'Used_for', 'linguistic annotation of scfs'], ['training and test data', 'Used_for', 'subcategorization acquisition']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14012738853503184, 0.12087912087912088, 0.1297935103244838]
text: In this paper we specialize the projective unifocal , bifo-cal , and trifocal tensors to the affine case , and show how the tensors obtained relate to the registered tensors encountered in previous work .
result: triple_list: [["projective unifocal , bifo-cal , and trifocal tensors", "Used_for", "affine case"], ["tensors", "Compare", "registered tensors"], ["registered tensors", "Used_for", "work"]]
pred: [('projective unifocal , bifo-cal , and trifocal tensors', 'Used_for', 'affine case'), ('tensors', 'Compare', 'registered tensors'), ('registered tensors', 'Used_for', 'work')]
trues: [['projective unifocal , bifo-cal , and trifocal tensors', 'Used_for', 'affine case']]
metrics_sample: [0.3333333333333333, 1.0, 0.5]
metrics_current: [0.14195583596214512, 0.1232876712328767, 0.13196480938416424]
text: This paper describes the impact of using different-quality references on evaluation .
result: The candidate relations for this text are:
Evaluate_for
The candidate entities for this text are:
quality references
evaluation

triple_list: [["quality references", "Evaluate_for", "evaluation"]]
pred: [('quality references', 'Evaluate_for', 'evaluation')]
trues: [['different-quality references', 'Used_for', 'evaluation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14150943396226415, 0.12295081967213115, 0.13157894736842105]
text: Many practical modeling problems involve discrete data that are best represented as draws from multinomial or categorical distributions .
result: triple_list: [["multinomial or categorical distributions", "Used_for", "discrete data"]]
pred: [('multinomial or categorical distributions', 'Used_for', 'discrete data')]
trues: [['discrete data', 'Used_for', 'modeling problems'], ['multinomial or categorical distributions', 'Used_for', 'modeling problems']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14106583072100312, 0.12228260869565218, 0.13100436681222707]
text: Our technique gives a substantial improvement in paraphrase classification accuracy over all of the other models used in the experiments .
result: triple_list: [["technique", "Evaluate_for", "paraphrase classification accuracy"]]
pred: [('technique', 'Evaluate_for', 'paraphrase classification accuracy')]
trues: [['technique', 'Compare', 'models'], ['paraphrase classification accuracy', 'Evaluate_for', 'technique'], ['paraphrase classification accuracy', 'Evaluate_for', 'models']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.140625, 0.12129380053908356, 0.13024602026049203]
text: It also shows that our method significantly outperforms the previous two dependency tree kernels on the 5 ACE relation major types .
result: triple_list: [["method", "Evaluate_for", "ACE relation major types"], ["method", "Compare", "dependency tree kernels"], ["dependency tree kernels", "Compare", "ACE relation major types"]]
pred: [('method', 'Evaluate_for', 'ACE relation major types'), ('method', 'Compare', 'dependency tree kernels'), ('dependency tree kernels', 'Compare', 'ACE relation major types')]
trues: [['method', 'Compare', 'dependency tree kernels']]
metrics_sample: [0.3333333333333333, 1.0, 0.5]
metrics_current: [0.14241486068111456, 0.12365591397849462, 0.1323741007194245]
text: We present Minimum Bayes-Risk ( MBR ) decoding for statistical machine translation .
result: triple_list: [["Minimum Bayes-Risk ( MBR ) decoding", "Used_for", "statistical machine translation"]]
pred: [('Minimum Bayes-Risk ( MBR ) decoding', 'Used_for', 'statistical machine translation')]
trues: [['Minimum Bayes-Risk ( MBR ) decoding', 'Used_for', 'statistical machine translation']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.14506172839506173, 0.1260053619302949, 0.13486370157819225]
text: The system is trained on 181,000 expert games and shows excellent prediction performance as indicated by its ability to perfectly predict the moves made by professional Go players in 34 % of test positions .
result: triple_list: [["system", "Used_for", "expert games"], ["expert games", "Hyponym_of", "Go players"], ["it", "Used_for", "test positions"]]
pred: [('system', 'Used_for', 'expert games'), ('expert games', 'Hyponym_of', 'Go players'), ('it', 'Used_for', 'test positions')]
trues: [['expert games', 'Used_for', 'system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1437308868501529, 0.12566844919786097, 0.1340941512125535]
text: As a Monte Carlo approach , ASA stochastically samples the parameter space , in contrast to local deterministic search .
result: triple_list: [["Monte Carlo approach", "Used_for", "ASA"]]
pred: [('Monte Carlo approach', 'Used_for', 'ASA')]
trues: [['ASA', 'Hyponym_of', 'Monte Carlo approach'], ['ASA', 'Compare', 'local deterministic search']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14329268292682926, 0.125, 0.13352272727272727]
text: When the scene exhibits a persistent dynamic behavior in time , such an assumption is violated and detection performance deteriorates .
result: triple_list: [["persistent dynamic behavior in time", "Part_of", "scene"]]
pred: [('persistent dynamic behavior in time', 'Part_of', 'scene')]
trues: [['persistent dynamic behavior', 'Feature_of', 'scene']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14285714285714285, 0.1246684350132626, 0.13314447592067988]
text: We provide a principled and provable solution for this problem ; it is parameterless and requires no data insights .
result: triple_list: [["problem", "Used_for", "solution"]]
pred: [('problem', 'Used_for', 'solution')]
trues: [['principled and provable solution', 'Used_for', 'problem']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14242424242424243, 0.12433862433862433, 0.1327683615819209]
text: Sentence boundary detection in speech is important for enriching speech recognition output , making it easier for humans to read and downstream modules to process .
result: The candidate relations for this text are:
Used_for
Used_for
Used_for
The candidate entities for this text are:
Sentence boundary detection in speech
speech recognition output
speech recognition output
humans
downstream modules
humans

triple_list: [["Sentence boundary detection in speech", "Used_for", "speech recognition output"], ["speech recognition output", "Used_for", "humans"], ["downstream modules", "Used_for", "humans"]]
pred: [('Sentence boundary detection in speech', 'Used_for', 'speech recognition output'), ('speech recognition output', 'Used_for', 'humans'), ('downstream modules', 'Used_for', 'humans')]
trues: [['Sentence boundary detection', 'Used_for', 'speech recognition output'], ['speech', 'Used_for', 'Sentence boundary detection']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14114114114114115, 0.12368421052631579, 0.1318373071528752]
text: Furthermore , we show how the recently developed efficient subwindow search ( ESS ) procedure [ 11 ] can be integrated into the last stage of our method .
result: triple_list: [["efficient subwindow search ( ESS ) procedure ", "Used_for", "method"]]
pred: [('efficient subwindow search ( ESS ) procedure ', 'Used_for', 'method')]
trues: [['subwindow search ( ESS ) procedure', 'Part_of', 'method']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1407185628742515, 0.12335958005249344, 0.1314685314685315]
text: Motivated by this semantic criterion we analyze the empirical quality of distributional word feature vectors and its impact on word similarity results , proposing an objective measure for evaluating feature vector quality .
result: triple_list: [["semantic criterion", "Used_for", "distributional word feature vectors"], ["empirical quality", "Evaluate_for", "distributional word feature vectors"], ["word similarity results", "Evaluate_for", "distributional word feature vectors"], ["objective measure", "Evaluate_for", "feature vector quality"]]
pred: [('semantic criterion', 'Used_for', 'distributional word feature vectors'), ('empirical quality', 'Evaluate_for', 'distributional word feature vectors'), ('word similarity results', 'Evaluate_for', 'distributional word feature vectors'), ('objective measure', 'Evaluate_for', 'feature vector quality')]
trues: [['semantic criterion', 'Evaluate_for', 'distributional word feature vectors'], ['distributional word feature vectors', 'Used_for', 'word similarity'], ['measure', 'Evaluate_for', 'feature vector quality']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1390532544378698, 0.12239583333333333, 0.13019390581717452]
text: Structural or numerical constraints can then be added locally to the reconstruction process through a constrained optimization scheme .
result: triple_list: [["Structural or numerical constraints", "Used_for", "reconstruction process"]]
pred: [('Structural or numerical constraints', 'Used_for', 'reconstruction process')]
trues: [['Structural or numerical constraints', 'Used_for', 'reconstruction process'], ['constrained optimization scheme', 'Used_for', 'Structural or numerical constraints']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.1415929203539823, 0.12435233160621761, 0.13241379310344828]
text: Simulated and experimental results show that our method recovers scene geometry with high subpixel precision , and that it can handle many challenges of active reconstruction systems .
result: triple_list: [["method", "Used_for", "it"], ["it", "Used_for", "active reconstruction systems"]]
pred: [('method', 'Used_for', 'it'), ('it', 'Used_for', 'active reconstruction systems')]
trues: [['method', 'Used_for', 'scene geometry'], ['subpixel precision', 'Feature_of', 'scene geometry'], ['it', 'Used_for', 'active reconstruction systems']]
metrics_sample: [0.5, 0.3333333333333333, 0.4]
metrics_current: [0.1436950146627566, 0.12596401028277635, 0.13424657534246576]
text: We also show that a good-quality MT system can be built from scratch by starting with a very small parallel corpus ( 100,000 words ) and exploiting a large non-parallel corpus .
result: triple_list: [["MT system", "Used_for", "parallel corpus"], ["MT system", "Used_for", "non-parallel corpus"]]
pred: [('MT system', 'Used_for', 'parallel corpus'), ('MT system', 'Used_for', 'non-parallel corpus')]
trues: [['parallel corpus', 'Used_for', 'MT system'], ['parallel corpus', 'Conjunction', 'non-parallel corpus'], ['non-parallel corpus', 'Used_for', 'MT system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14285714285714285, 0.125, 0.13333333333333333]
text: To evaluate our proposed model , we build a large streaming video dataset with annotations .
result: triple_list: [["streaming video dataset", "Evaluate_for", "model"], ["annotations", "Used_for", "streaming video dataset"]]
pred: [('streaming video dataset', 'Evaluate_for', 'model'), ('annotations', 'Used_for', 'streaming video dataset')]
trues: [['streaming video dataset', 'Evaluate_for', 'model']]
metrics_sample: [0.5, 1.0, 0.6666666666666666]
metrics_current: [0.14492753623188406, 0.1272264631043257, 0.13550135501355012]
text: In this paper , we evaluate the use of a conditional random field ( CRF ) for this task and relate results with this model to our prior work .
result: triple_list: [["conditional random field ( CRF )", "Used_for", "task"]]
pred: [('conditional random field ( CRF )', 'Used_for', 'task')]
trues: [['conditional random field ( CRF )', 'Used_for', 'task']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.14739884393063585, 0.12944162436548223, 0.13783783783783785]
text: Our morphological analyzer has done all the necessary work for the recognition and classification of proper names , numerical and temporal expressions , i.e. Named Entity ( NE ) items in the Japanese text .
result: triple_list: [["morphological analyzer", "Used_for", "recognition and classification of proper names , numerical and temporal expressions , i.e. Named Entity ( NE ) items"], ["Japanese text", "Used_for", "Named Entity ( NE ) items"]]
pred: [('morphological analyzer', 'Used_for', 'recognition and classification of proper names , numerical and temporal expressions , i.e. Named Entity ( NE ) items'), ('Japanese text', 'Used_for', 'Named Entity ( NE ) items')]
trues: [['morphological analyzer', 'Used_for', 'recognition and classification of proper names , numerical and temporal expressions'], ['Named Entity ( NE ) items', 'Hyponym_of', 'proper names , numerical and temporal expressions'], ['Named Entity ( NE ) items', 'Part_of', 'Japanese text']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14655172413793102, 0.12846347607052896, 0.13691275167785236]
text: The intentional structure captures the discourse-relevant purposes , expressed in each of the linguistic segments as well as relationships among them .
result: The candidate relations for this text are:
Feature_of
The candidate entities for this text are:
linguistic segments
intentional structure

triple_list: [["linguistic segments", "Feature_of", "intentional structure"]]
pred: [('linguistic segments', 'Feature_of', 'intentional structure')]
trues: [['intentional structure', 'Used_for', 'discourse-relevant purposes']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14613180515759314, 0.12814070351758794, 0.13654618473895586]
text: The system is implemented entirely in Prolog , a programming language based on logic .
result: triple_list: [["Prolog ", "Conjunction", "programming language"], ["logic ", "Used_for", "Prolog"]]
pred: [('Prolog ', 'Conjunction', 'programming language'), ('logic ', 'Used_for', 'Prolog')]
trues: [['Prolog', 'Used_for', 'system'], ['Prolog', 'Hyponym_of', 'programming language'], ['logic', 'Used_for', 'programming language']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1452991452991453, 0.12718204488778054, 0.1356382978723404]
text: Our numerical hybrid local and global mode-seeking tracker is validated on challenging airborne videos with heavy occlusion and large camera motions .
result: triple_list: [["numerical hybrid local and global mode-seeking tracker", "Used_for", "airborne videos"]]
pred: [('numerical hybrid local and global mode-seeking tracker', 'Used_for', 'airborne videos')]
trues: [['airborne videos', 'Evaluate_for', 'numerical hybrid local and global mode-seeking tracker'], ['heavy occlusion', 'Feature_of', 'airborne videos'], ['heavy occlusion', 'Conjunction', 'camera motions'], ['camera motions', 'Feature_of', 'airborne videos']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14488636363636365, 0.1259259259259259, 0.1347424042272127]
text: The goal is to sample a small set of records over which evaluating aggregate queries can be done both efficiently and accurately .
result: triple_list: [["efficient and accurate", "Evaluate_for", "aggregate queries"]]
pred: [('efficient and accurate', 'Evaluate_for', 'aggregate queries')]
trues: [['aggregate queries', 'Evaluate_for', 'records']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14447592067988668, 0.12561576354679804, 0.13438735177865613]
text: A mixed-signal paradigm is presented for high-resolution parallel inner-product computation in very high dimensions , suitable for efficient implementation of kernels in image processing .
result: triple_list: [["high-resolution parallel inner-product computation in very high dimensions", "Used_for", "mixed-signal paradigm"], ["high-resolution parallel inner-product computation in very high dimensions", "Used_for", "kernels"], ["image processing", "Feature_of", "kernels"]]
pred: [('high-resolution parallel inner-product computation in very high dimensions', 'Used_for', 'mixed-signal paradigm'), ('high-resolution parallel inner-product computation in very high dimensions', 'Used_for', 'kernels'), ('image processing', 'Feature_of', 'kernels')]
trues: [['mixed-signal paradigm', 'Used_for', 'high-resolution parallel inner-product computation'], ['mixed-signal paradigm', 'Used_for', 'kernels'], ['kernels', 'Used_for', 'image processing']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14325842696629212, 0.12469437652811736, 0.13333333333333333]
text: The psycholinguistic literature provides evidence for syntactic priming , i.e. , the tendency to repeat structures .
result: The candidate relations for this text are:
Feature_of
The candidate entities for this text are:
syntactic priming
psycholinguistic literature

triple_list: [["syntactic priming", "Feature_of", "psycholinguistic literature"]]
pred: [('syntactic priming', 'Feature_of', 'psycholinguistic literature')]
trues: [['psycholinguistic literature', 'Used_for', 'syntactic priming']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14285714285714285, 0.12439024390243902, 0.13298565840938723]
text: Using this approach , we extract parallel data from large Chinese , Arabic , and English non-parallel newspaper corpora .
result: triple_list: [["Chinese , Arabic , and English non-parallel newspaper corpora", "Used_for", "parallel data"]]
pred: [('Chinese , Arabic , and English non-parallel newspaper corpora', 'Used_for', 'parallel data')]
trues: [['approach', 'Used_for', 'parallel data'], ['parallel data', 'Part_of', 'Chinese , Arabic , and English non-parallel newspaper corpora']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1424581005586592, 0.12378640776699029, 0.13246753246753246]
text: We demonstrate that for certain field structured extraction tasks , such as classified advertisements and bibliographic citations , small amounts of prior knowledge can be used to learn effective models in a primarily unsupervised fashion .
result: triple_list: [["classified advertisements and bibliographic citations", "Feature_of", "field structured extraction tasks"], ["prior knowledge", "Used_for", "models"], ["prior knowledge", "Part_of", "unsupervised fashion"]]
pred: [('classified advertisements and bibliographic citations', 'Feature_of', 'field structured extraction tasks'), ('prior knowledge', 'Used_for', 'models'), ('prior knowledge', 'Part_of', 'unsupervised fashion')]
trues: [['classified advertisements', 'Hyponym_of', 'field structured extraction tasks'], ['classified advertisements', 'Conjunction', 'bibliographic citations'], ['bibliographic citations', 'Hyponym_of', 'field structured extraction tasks'], ['prior knowledge', 'Used_for', 'field structured extraction tasks']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14127423822714683, 0.12259615384615384, 0.1312741312741313]
text: We evaluated the topic signatures on a WSD task , where we trained a second-order vector cooccurrence algorithm on standard WSD datasets , with promising results .
result: triple_list: [["WSD task", "Used_for", "topic signatures"], ["WSD task", "Part_of", "second-order vector cooccurrence algorithm"], ["WSD datasets", "Hyponym_of", "WSD task"]]
pred: [('WSD task', 'Used_for', 'topic signatures'), ('WSD task', 'Part_of', 'second-order vector cooccurrence algorithm'), ('WSD datasets', 'Hyponym_of', 'WSD task')]
trues: [['WSD task', 'Evaluate_for', 'topic signatures'], ['WSD datasets', 'Used_for', 'second-order vector cooccurrence algorithm']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1401098901098901, 0.12200956937799043, 0.13043478260869565]
text: Using these ideas together , the resulting tagger gives a 97.24 % accuracy on the Penn Treebank WSJ , an error reduction of 4.4 % on the best previous single automatically learned tagging result .
result: triple_list: [["accuracy", "Evaluate_for", "tagger"], ["Penn Treebank WSJ", "Used_for", "tagger"], ["error reduction", "Evaluate_for", "tagger"], ["error reduction", "Evaluate_for", "single automatically learned tagging result"]]
pred: [('accuracy', 'Evaluate_for', 'tagger'), ('Penn Treebank WSJ', 'Used_for', 'tagger'), ('error reduction', 'Evaluate_for', 'tagger'), ('error reduction', 'Evaluate_for', 'single automatically learned tagging result')]
trues: [['accuracy', 'Evaluate_for', 'tagger'], ['Penn Treebank WSJ', 'Evaluate_for', 'tagger'], ['error', 'Evaluate_for', 'tagger']]
metrics_sample: [0.25, 0.3333333333333333, 0.28571428571428575]
metrics_current: [0.14130434782608695, 0.12351543942992874, 0.13181242078580482]
text: Indeed , automatic evaluations need high-quality data that allow the comparison of both automatic and human translations .
result: The candidate relations for this text are:
Compare
Used_for
Used_for
The candidate entities for this text are:
automatic evaluations
human translations
high-quality data
automatic evaluations
high-quality data
human translations

triple_list: [["automatic evaluations", "Compare", "human translations"], ["high-quality data", "Used_for", "automatic evaluations"], ["high-quality data", "Used_for", "human translations"]]
pred: [('automatic evaluations', 'Compare', 'human translations'), ('high-quality data', 'Used_for', 'automatic evaluations'), ('high-quality data', 'Used_for', 'human translations')]
trues: [['high-quality data', 'Evaluate_for', 'automatic evaluations']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14016172506738545, 0.12322274881516587, 0.13114754098360654]
text: However , acquiring the necessary training data is typically a tedious and time consuming task that involves manual interaction , active sensing devices and/or synthetic scenes .
result: triple_list: [["training data", "Used_for", "acquiring necessary training data"], ["manual interaction", "Used_for", "training data"], ["manual interaction", "Hyponym_of", "active sensing devices"], ["synthetic scenes", "Hyponym_of", "training data"]]
pred: [('training data', 'Used_for', 'acquiring necessary training data'), ('manual interaction', 'Used_for', 'training data'), ('manual interaction', 'Hyponym_of', 'active sensing devices'), ('synthetic scenes', 'Hyponym_of', 'training data')]
trues: [['manual interaction', 'Used_for', 'task'], ['manual interaction', 'Conjunction', 'active sensing devices'], ['active sensing devices', 'Used_for', 'task'], ['active sensing devices', 'Conjunction', 'synthetic scenes'], ['synthetic scenes', 'Used_for', 'task']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13866666666666666, 0.12177985948477751, 0.12967581047381546]
text: Here , we leverage a logistic stick-breaking representation and recent innovations in Plya-gamma augmentation to reformu-late the multinomial distribution in terms of latent variables with jointly Gaussian likelihoods , enabling us to take advantage of a host of Bayesian inference techniques for Gaussian models with minimal overhead .
result: triple_list: [["stick-breaking representation", "Used_for", "logistic stick-breaking representation"], ["logistic stick-breaking representation", "Hyponym_of", "multinomial distribution"], ["multinomial distribution", "Used_for", "latent variables with jointly Gaussian likelihoods"], ["latent variables with jointly Gaussian likelihoods", "Used_for", "Bayesian inference techniques"], ["Bayesian inference techniques", "Part_of", "Gaussian models"]]
pred: [('stick-breaking representation', 'Used_for', 'logistic stick-breaking representation'), ('logistic stick-breaking representation', 'Hyponym_of', 'multinomial distribution'), ('multinomial distribution', 'Used_for', 'latent variables with jointly Gaussian likelihoods'), ('latent variables with jointly Gaussian likelihoods', 'Used_for', 'Bayesian inference techniques'), ('Bayesian inference techniques', 'Part_of', 'Gaussian models')]
trues: [['logistic stick-breaking representation', 'Used_for', 'multinomial distribution'], ['Plya-gamma augmentation', 'Used_for', 'multinomial distribution'], ['latent variables', 'Part_of', 'multinomial distribution'], ['jointly Gaussian likelihoods', 'Feature_of', 'latent variables'], ['Bayesian inference techniques', 'Used_for', 'Gaussian models'], ['minimal overhead', 'Feature_of', 'Gaussian models']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1368421052631579, 0.12009237875288684, 0.12792127921279214]
text: We evaluate several proposals for constraining them , basing our assessment on computational tractability and explanatory adequacy .
result: The candidate relations for this text are:
Used_for
Hyponym_of
Conjunction
Hyponym_of
The candidate entities for this text are:
computational tractability
them
computational tractability
explanatory adequacy
explanatory adequacy
them

triple_list: [["computational tractability", "Used_for", "them"], ["computational tractability", "Hyponym_of", "explanatory adequacy"], ["explanatory adequacy", "Conjunction", "them"]]
pred: [('computational tractability', 'Used_for', 'them'), ('computational tractability', 'Hyponym_of', 'explanatory adequacy'), ('explanatory adequacy', 'Conjunction', 'them')]
trues: [['computational tractability and explanatory adequacy', 'Evaluate_for', 'them']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13577023498694518, 0.11981566820276497, 0.12729498164014688]
text: Thus the ASR system is designed to deal with what we refer to as Word Spotting and Noise Spotting capabilities .
result: triple_list: [["Word Spotting", "Conjunction", "Noise Spotting"], ["Word Spotting", "Feature_of", "ASR system"], ["Noise Spotting", "Feature_of", "ASR system"]]
pred: [('Word Spotting', 'Conjunction', 'Noise Spotting'), ('Word Spotting', 'Feature_of', 'ASR system'), ('Noise Spotting', 'Feature_of', 'ASR system')]
trues: [['ASR system', 'Used_for', 'Word Spotting'], ['ASR system', 'Used_for', 'Noise Spotting capabilities']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13471502590673576, 0.11926605504587157, 0.12652068126520682]
text: Towards the modeling of the dynamic characteristics , optical flow is computed and utilized as a feature in a higher dimensional space .
result: triple_list: [["optical flow", "Used_for", "higher dimensional space"]]
pred: [('optical flow', 'Used_for', 'higher dimensional space')]
trues: [['optical flow', 'Used_for', 'modeling of the dynamic characteristics'], ['optical flow', 'Used_for', 'feature'], ['feature', 'Used_for', 'modeling of the dynamic characteristics'], ['higher dimensional space', 'Feature_of', 'feature']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1343669250645995, 0.11818181818181818, 0.12575574365175332]
text: Our technique is based on an improved , dynamic-programming , stereo algorithm for efficient novel-view generation .
result: triple_list: [["dynamic-programming , stereo algorithm", "Used_for", "technique"], ["dynamic-programming , stereo algorithm", "Evaluate_for", "efficient novel-view generation"]]
pred: [('dynamic-programming , stereo algorithm', 'Used_for', 'technique'), ('dynamic-programming , stereo algorithm', 'Evaluate_for', 'efficient novel-view generation')]
trues: [['technique', 'Used_for', 'novel-view generation'], ['dynamic-programming , stereo algorithm', 'Used_for', 'technique']]
metrics_sample: [0.5, 0.5, 0.5]
metrics_current: [0.13624678663239073, 0.11990950226244344, 0.12755716004813478]
text: This statistical approach aims to minimize expected loss of translation errors under loss functions that measure translation performance .
result: triple_list: [["statistical approach", "Evaluate_for", "loss functions"], ["loss functions", "Evaluate_for", "translation performance"]]
pred: [('statistical approach', 'Evaluate_for', 'loss functions'), ('loss functions', 'Evaluate_for', 'translation performance')]
trues: [['loss functions', 'Evaluate_for', 'translation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13554987212276215, 0.11963882618510158, 0.12709832134292567]
text: While current approaches are developed by only considering the low rank plus sparse structure , in many applications , side information of row and/or column entities may also be given , and it is still unclear to what extent could such information help robust PCA .
result: triple_list: [["low rank plus sparse structure", "Part_of", "it"], ["side information of row and/or column entities", "Conjunction", "low rank plus sparse structure"], ["side information of row and/or column entities", "Part_of", "it"]]
pred: [('low rank plus sparse structure', 'Part_of', 'it'), ('side information of row and/or column entities', 'Conjunction', 'low rank plus sparse structure'), ('side information of row and/or column entities', 'Part_of', 'it')]
trues: [['low rank plus sparse structure', 'Used_for', 'approaches'], ['information', 'Used_for', 'robust PCA']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13451776649746192, 0.11910112359550562, 0.12634088200238378]
text: Fast algorithms for nearest neighbor ( NN ) search have in large part focused on 2 distance .
result: triple_list: [["nearest neighbor ( NN ) search", "Used_for", "Fast algorithms"]]
pred: [('nearest neighbor ( NN ) search', 'Used_for', 'Fast algorithms')]
trues: [['Fast algorithms', 'Used_for', 'nearest neighbor ( NN ) search']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1341772151898734, 0.11883408071748879, 0.12604042806183113]
text: In particular , our guarantee suggests that a substantial amount of low rank matrices , which can not be recovered by standard robust PCA , become re-coverable by our proposed method .
result: triple_list: [["low rank matrices", "Used_for", "low rank matrices"]]
pred: [('low rank matrices', 'Used_for', 'low rank matrices')]
trues: [['method', 'Used_for', 'low rank matrices']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13383838383838384, 0.1185682326621924, 0.1257413997627521]
text: Given the video streams acquired by two cameras placed on either side of a computer monitor , the proposed algorithm synthesises images from a virtual camera in arbitrary position ( typically located within the monitor ) to facilitate eye contact .
result: triple_list: [["video streams", "Used_for", "algorithm"], ["cameras", "Part_of", "video streams"], ["algorithm", "Used_for", "images"], ["virtual camera", "Used_for", "images"], ["arbitrary position", "Hyponym_of", "virtual camera"], ["eye contact", "Used_for", "images"]]
pred: [('video streams', 'Used_for', 'algorithm'), ('cameras', 'Part_of', 'video streams'), ('algorithm', 'Used_for', 'images'), ('virtual camera', 'Used_for', 'images'), ('arbitrary position', 'Hyponym_of', 'virtual camera'), ('eye contact', 'Used_for', 'images')]
trues: [['cameras', 'Used_for', 'video streams'], ['algorithm', 'Used_for', 'eye contact'], ['virtual camera', 'Used_for', 'images'], ['arbitrary position', 'Feature_of', 'virtual camera']]
metrics_sample: [0.16666666666666666, 0.25, 0.2]
metrics_current: [0.13432835820895522, 0.1197339246119734, 0.12661195779601406]
text: We have built and will demonstrate an application of this approach called LCS-Marine .
result: triple_list: [["LCS-Marine", "Used_for", "approach"]]
pred: [('LCS-Marine', 'Used_for', 'approach')]
trues: [['approach', 'Used_for', 'LCS-Marine']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13399503722084366, 0.11946902654867257, 0.12631578947368421]
text: This probably occurs because each model has different strengths and weaknesses for modeling the knowledge sources .
result: triple_list: [["model", "Used_for", "knowledge sources"]]
pred: [('model', 'Used_for', 'knowledge sources')]
trues: [['model', 'Used_for', 'knowledge sources']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.13613861386138615, 0.12141280353200883, 0.12835472578763127]
text: We show promising results in both the detection and viewpoint classification tasks on these two challenging datasets .
result: triple_list: [["detection and viewpoint classification tasks", "Conjunction", "datasets"], ["detection and viewpoint classification tasks", "Used_for", "two challenging datasets"]]
pred: [('detection and viewpoint classification tasks', 'Conjunction', 'datasets'), ('detection and viewpoint classification tasks', 'Used_for', 'two challenging datasets')]
trues: [['datasets', 'Evaluate_for', 'detection and viewpoint classification tasks']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1354679802955665, 0.1211453744493392, 0.12790697674418605]
text: Our results show that MT evaluation techniques are able to produce useful features for paraphrase classification and to a lesser extent entailment .
result: triple_list: [["MT evaluation techniques", "Used_for", "features"], ["paraphrase classification", "Evaluate_for", "MT evaluation techniques"], ["features", "Used_for", "paraphrase classification"], ["entailment", "Evaluate_for", "MT evaluation techniques"], ["entailment", "Evaluate_for", "features"]]
pred: [('MT evaluation techniques', 'Used_for', 'features'), ('paraphrase classification', 'Evaluate_for', 'MT evaluation techniques'), ('features', 'Used_for', 'paraphrase classification'), ('entailment', 'Evaluate_for', 'MT evaluation techniques'), ('entailment', 'Evaluate_for', 'features')]
trues: [['MT evaluation techniques', 'Used_for', 'features'], ['MT evaluation techniques', 'Used_for', 'paraphrase classification'], ['MT evaluation techniques', 'Used_for', 'entailment'], ['paraphrase classification', 'Conjunction', 'entailment']]
metrics_sample: [0.2, 0.25, 0.22222222222222224]
metrics_current: [0.1362530413625304, 0.1222707423580786, 0.1288837744533947]
text: For LR ( 0 ) grammars , our algorithm is closely related to the recursive ascent parsers recently discovered by Kruse-man Aretz [ 1 ] and Roberts [ 2 ] .
result: triple_list: [["LR ( 0 ) grammars", "Used_for", "algorithm"], ["recursive ascent parsers", "Used_for", "algorithm"], ["Kruse-man Aretz [ 1 ]", "Used_for", "recursive ascent parsers"], ["Roberts [ 2 ]", "Used_for", "recursive ascent parsers"]]
pred: [('LR ( 0 ) grammars', 'Used_for', 'algorithm'), ('recursive ascent parsers', 'Used_for', 'algorithm'), ('Kruse-man Aretz [ 1 ]', 'Used_for', 'recursive ascent parsers'), ('Roberts [ 2 ]', 'Used_for', 'recursive ascent parsers')]
trues: [['algorithm', 'Used_for', 'LR ( 0 ) grammars'], ['algorithm', 'Conjunction', 'recursive ascent parsers']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13493975903614458, 0.12173913043478261, 0.12799999999999997]
text: With the aid of a logic-based grammar formalism called extraposition grammars , Chat-80 translates English questions into the Prolog subset of logic .
result: triple_list: [["logic-based grammar formalism", "Used_for", "Chat-80"]]
pred: [('logic-based grammar formalism', 'Used_for', 'Chat-80')]
trues: [['extraposition grammars', 'Hyponym_of', 'logic-based grammar formalism'], ['extraposition grammars', 'Used_for', 'Chat-80']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1346153846153846, 0.12121212121212122, 0.1275626423690205]
text: We argue that it is necessary to draw a line between generalizable semantic principles and domain-specific semantic information .
result: The candidate relations for this text are:
Compare
The candidate entities for this text are:
generalizable semantic principles
domain-specific semantic information

triple_list: [["generalizable semantic principles", "Compare", "domain-specific semantic information"]]
pred: [('generalizable semantic principles', 'Compare', 'domain-specific semantic information')]
trues: [['generalizable semantic principles', 'Compare', 'domain-specific semantic information']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.1366906474820144, 0.12311015118790497, 0.12954545454545457]
text: Finally , a novel feature weighting and selection function is presented , which yields superior feature vectors and better word similarity performance .
result: triple_list: [["feature weighting and selection function", "Evaluate_for", "feature vectors"], ["feature weighting and selection function", "Evaluate_for", "word similarity"]]
pred: [('feature weighting and selection function', 'Evaluate_for', 'feature vectors'), ('feature weighting and selection function', 'Evaluate_for', 'word similarity')]
trues: [['feature weighting and selection function', 'Used_for', 'feature vectors'], ['feature weighting and selection function', 'Used_for', 'word similarity'], ['feature vectors', 'Conjunction', 'word similarity']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1360381861575179, 0.1223175965665236, 0.1288135593220339]
text: We propose to incorporate a priori geometric constraints in a 3 -- D stereo reconstruction scheme to cope with the many cases where image information alone is not sufficient to accurately recover 3 -- D shape .
result: triple_list: [["geometric constraints", "Part_of", "3 -- D stereo reconstruction scheme"], ["image information", "Used_for", "3 -- D stereo reconstruction scheme"], ["image information", "Used_for", "accurate recovery 3 -- D shape"]]
pred: [('geometric constraints', 'Part_of', '3 -- D stereo reconstruction scheme'), ('image information', 'Used_for', '3 -- D stereo reconstruction scheme'), ('image information', 'Used_for', 'accurate recovery 3 -- D shape')]
trues: [['priori geometric constraints', 'Part_of', '3 -- D stereo reconstruction scheme'], ['image information', 'Used_for', '3 -- D shape']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13507109004739337, 0.12179487179487179, 0.12808988764044943]
text: The combined approach is formulated in the framework of Bayesian statistics to account for the robust-ness requirement in image understanding .
result: The candidate relations for this text are:
Used_for
Feature_of
The candidate entities for this text are:
Bayesian statistics
approach
robust-ness requirement
image understanding

triple_list: [["Bayesian statistics", "Used_for", "approach"], ["robust-ness requirement", "Feature_of", "image understanding"]]
pred: [('Bayesian statistics', 'Used_for', 'approach'), ('robust-ness requirement', 'Feature_of', 'image understanding')]
trues: [['approach', 'Used_for', 'robust-ness requirement in image understanding'], ['Bayesian statistics', 'Used_for', 'approach']]
metrics_sample: [0.5, 0.5, 0.5]
metrics_current: [0.13679245283018868, 0.12340425531914893, 0.1297539149888143]
text: Examples are given that demonstrate the robustness of the new algorithm to spatial and temporal artefacts for long stereo video streams .
result: triple_list: [["algorithm", "Used_for", "spatial and temporal artefacts"]]
pred: [('algorithm', 'Used_for', 'spatial and temporal artefacts')]
trues: [['robustness', 'Evaluate_for', 'algorithm'], ['algorithm', 'Used_for', 'spatial and temporal artefacts'], ['spatial and temporal artefacts', 'Used_for', 'long stereo video streams']]
metrics_sample: [1.0, 0.3333333333333333, 0.5]
metrics_current: [0.1388235294117647, 0.12473572938689217, 0.13140311804008908]
text: It is presented as a generalization of the recursive descent parser .
result: triple_list: [["generalization of the recursive descent parser", "Is_part_of", "It"]]
pred: [('generalization of the recursive descent parser', 'Is_part_of', 'It')]
trues: [['recursive descent parser', 'Used_for', 'It']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13849765258215962, 0.12447257383966245, 0.1311111111111111]
text: Related work applies MINPRAN to complex range and intensity data 23 ] .
result: triple_list: [["MINPRAN", "Feature_of", "complex range and intensity data"]]
pred: [('MINPRAN', 'Feature_of', 'complex range and intensity data')]
trues: [['MINPRAN', 'Used_for', 'complex range'], ['MINPRAN', 'Used_for', 'intensity data']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13817330210772832, 0.12394957983193278, 0.13067552602436325]
text: An experimental evaluation of summarization quality shows a close correlation between the automatic parse-based evaluation and a manual evaluation of generated strings .
result: triple_list: [["parse-based evaluation", "Used_for", "summarization quality"], ["manual evaluation of generated strings", "Conjunction", "parse-based evaluation"]]
pred: [('parse-based evaluation', 'Used_for', 'summarization quality'), ('manual evaluation of generated strings', 'Conjunction', 'parse-based evaluation')]
trues: [['summarization quality', 'Evaluate_for', 'automatic parse-based evaluation'], ['automatic parse-based evaluation', 'Compare', 'manual evaluation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13752913752913754, 0.12343096234309624, 0.13009922822491732]
text: While Plume is well adapted to simple declarative and imperative utterances , it handles passives , relative clauses and interrogatives in an ad hoc manner leading to patchy syntactic coverage .
result: triple_list: [["Plume", "Used_for", "declarative and imperative utterances"]]
pred: [('Plume', 'Used_for', 'declarative and imperative utterances')]
trues: [['Plume', 'Used_for', 'declarative and imperative utterances'], ['it', 'Used_for', 'passives'], ['it', 'Used_for', 'relative clauses'], ['it', 'Used_for', 'interrogatives'], ['passives', 'Conjunction', 'relative clauses'], ['relative clauses', 'Conjunction', 'interrogatives']]
metrics_sample: [1.0, 0.16666666666666666, 0.2857142857142857]
metrics_current: [0.13953488372093023, 0.12396694214876033, 0.1312910284463895]
text: In previous work , we have developed hidden Markov model ( HMM ) and maximum entropy ( Maxent ) classifiers that integrate textual and prosodic knowledge sources for detecting sentence boundaries .
result: triple_list: [["hidden Markov model ( HMM ) ", "Used_for", "sentence boundaries"], ["hidden Markov model ( HMM ) ", "Used_for", "maximum entropy ( Maxent ) classifiers"], ["prosodic knowledge sources", "Used_for", "hidden Markov model ( HMM )"], ["maximum entropy ( Maxent ) classifiers", "Conjunction", "prosodic knowledge sources"], ["maximum entropy ( Maxent ) classifiers", "Used_for", "sentence boundaries"]]
pred: [('hidden Markov model ( HMM ) ', 'Used_for', 'sentence boundaries'), ('hidden Markov model ( HMM ) ', 'Used_for', 'maximum entropy ( Maxent ) classifiers'), ('prosodic knowledge sources', 'Used_for', 'hidden Markov model ( HMM )'), ('maximum entropy ( Maxent ) classifiers', 'Conjunction', 'prosodic knowledge sources'), ('maximum entropy ( Maxent ) classifiers', 'Used_for', 'sentence boundaries')]
trues: [['hidden Markov model ( HMM ) and maximum entropy ( Maxent ) classifiers', 'Used_for', 'detecting sentence boundaries'], ['textual and prosodic knowledge sources', 'Used_for', 'hidden Markov model ( HMM ) and maximum entropy ( Maxent ) classifiers']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13793103448275862, 0.12345679012345678, 0.13029315960912052]
text: We extract a set of heuristic principles from a corpus-based sample and formulate them as probabilistic Horn clauses .
result: triple_list: [["heuristic principles", "Used_for", "corpus-based sample"]]
pred: [('heuristic principles', 'Used_for', 'corpus-based sample')]
trues: [['corpus-based sample', 'Used_for', 'heuristic principles'], ['probabilistic Horn clauses', 'Feature_of', 'heuristic principles']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13761467889908258, 0.12295081967213115, 0.12987012987012989]
text: We then derive a scalable stochastic gradient descent algorithm for the resulting learning problem .
result: triple_list: [["stochastic gradient descent algorithm", "Used_for", "learning problem"]]
pred: [('stochastic gradient descent algorithm', 'Used_for', 'learning problem')]
trues: [['stochastic gradient descent algorithm', 'Used_for', 'learning problem']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.13958810068649885, 0.12474437627811862, 0.13174946004319654]
text: We present a scanning method that recovers dense sub-pixel camera-projector correspondence without requiring any photometric calibration nor preliminary knowledge of their relative geometry .
result: triple_list: [["scanning method", "Used_for", "camera-projector correspondence"]]
pred: [('scanning method', 'Used_for', 'camera-projector correspondence')]
trues: [['scanning method', 'Used_for', 'dense sub-pixel camera-projector correspondence']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13926940639269406, 0.12448979591836734, 0.13146551724137928]
text: Kernel space embedding decouples the training and prediction costs from the data dimension and enables us to plug inarbitrary distance measures which are more natural for the features .
result: triple_list: [["training and prediction costs", "Conjunction", "distance measures"], ["features", "Hyponym_of", "distance measures"]]
pred: [('training and prediction costs', 'Conjunction', 'distance measures'), ('features', 'Hyponym_of', 'distance measures')]
trues: [['Kernel space embedding', 'Used_for', 'inarbitrary distance measures']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13863636363636364, 0.12423625254582485, 0.1310418904403867]
text: In order to perform an exhaustive comparison , we also evaluate a hand-crafted template-based generation component , two rule-based sentence planners , and two baseline sentence planners .
result: triple_list: [["template-based generation component", "Evaluate_for", "hand-crafted template-based generation component"], ["rule-based sentence planners", "Evaluate_for", "rule-based sentence planners"], ["baseline sentence planners", "Evaluate_for", "baseline sentence planners"]]
pred: [('template-based generation component', 'Evaluate_for', 'hand-crafted template-based generation component'), ('rule-based sentence planners', 'Evaluate_for', 'rule-based sentence planners'), ('baseline sentence planners', 'Evaluate_for', 'baseline sentence planners')]
trues: [['hand-crafted template-based generation component', 'Conjunction', 'rule-based sentence planners'], ['rule-based sentence planners', 'Conjunction', 'baseline sentence planners']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13769751693002258, 0.12373225152129817, 0.13034188034188035]
text: We investigate the verbal and nonverbal means for grounding , and propose a design for embodied conversational agents that relies on both kinds of signals to establish common ground in human-computer interaction .
result: triple_list: [["verbal and nonverbal means", "Used_for", "grounding"], ["grounding", "Part_of", "embodied conversational agents"], ["kinds of signals", "Used_for", "common ground"]]
pred: [('verbal and nonverbal means', 'Used_for', 'grounding'), ('grounding', 'Part_of', 'embodied conversational agents'), ('kinds of signals', 'Used_for', 'common ground')]
trues: [['verbal and nonverbal means', 'Used_for', 'grounding'], ['design', 'Used_for', 'embodied conversational agents'], ['common ground', 'Used_for', 'human-computer interaction']]
metrics_sample: [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]
metrics_current: [0.13901345291479822, 0.125, 0.1316348195329087]
text: They improve the reconstruction results and enforce their consistency with a priori knowledge about object shape .
result: triple_list: [["reconstruction results", "Evaluate_for", "They"], ["priori knowledge about object shape", "Evaluate_for", "consistency"]]
pred: [('reconstruction results', 'Evaluate_for', 'They'), ('priori knowledge about object shape', 'Evaluate_for', 'consistency')]
trues: [['They', 'Used_for', 'reconstruction'], ['object shape', 'Feature_of', 'priori knowledge']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13839285714285715, 0.12449799196787148, 0.13107822410147993]
text: The surface realizations of morphological constructions are constrained and modified by a number of phonetic rules such as vowel harmony .
result: triple_list: [["morphological constructions", "Feature_of", "surface realizations"]]


pred: [('morphological constructions', 'Feature_of', 'surface realizations')]
trues: [['phonetic rules', 'Used_for', 'surface realizations of morphological constructions'], ['vowel harmony', 'Hyponym_of', 'phonetic rules']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13808463251670378, 0.124, 0.13066385669125397]
text: In this model , on-line handwriting is considered as a modulation of a simple cycloidal pen motion , described by two coupled oscillations with a constant linear drift along the line of the writing .
result: triple_list: [["on-line handwriting", "Used_for", "model"]]
pred: [('on-line handwriting', 'Used_for', 'model')]
trues: [['model', 'Used_for', 'on-line handwriting'], ['on-line handwriting', 'Part_of', 'cycloidal pen motion']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13777777777777778, 0.12350597609561753, 0.13025210084033614]
text: Listen-Communicate-Show ( LCS ) is a new paradigm for human interaction with data sources .
result: triple_list: [["Listen-Communicate-Show ( LCS )", "Used_for", "human interaction"]]
pred: [('Listen-Communicate-Show ( LCS )', 'Used_for', 'human interaction')]
trues: [['Listen-Communicate-Show ( LCS )', 'Used_for', 'human interaction with data sources']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13747228381374724, 0.12326043737574553, 0.12997903563941302]
text: The integrated learning system has been experimentally validated in simulated construction and ooce domains .
result: triple_list: [["integrated learning system", "Used_for", "simulated construction and ooce domains"]]
pred: [('integrated learning system', 'Used_for', 'simulated construction and ooce domains')]
trues: [['simulated construction', 'Evaluate_for', 'integrated learning system'], ['simulated construction', 'Conjunction', 'ooce domains'], ['ooce domains', 'Evaluate_for', 'integrated learning system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13716814159292035, 0.1225296442687747, 0.12943632567849686]
text: The problem of blind separation of underdetermined instantaneous mixtures of independent signals is addressed through a method relying on nonstationarity of the original signals .
result: triple_list: [["blind separation of underdetermined instantaneous mixtures of independent signals", "Used_for", "method"]]
pred: [('blind separation of underdetermined instantaneous mixtures of independent signals', 'Used_for', 'method')]
trues: [['method', 'Used_for', 'blind separation of underdetermined instantaneous mixtures of independent signals'], ['nonstationarity', 'Used_for', 'method']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1368653421633554, 0.1220472440944882, 0.1290322580645161]
text: Techniques for automatically training modules of a natural language generator have recently been proposed , but a fundamental concern is whether the quality of utterances produced with trainable components can compete with hand-crafted template-based or rule-based approaches .
result: triple_list: [["Techniques", "Used_for", "modules of a natural language generator"], ["natural language generator", "Compare", "template-based or rule-based approaches"]]
pred: [('Techniques', 'Used_for', 'modules of a natural language generator'), ('natural language generator', 'Compare', 'template-based or rule-based approaches')]
trues: [['Techniques', 'Used_for', 'automatically training modules'], ['automatically training modules', 'Part_of', 'natural language generator'], ['utterances', 'Evaluate_for', 'trainable components'], ['utterances', 'Evaluate_for', 'hand-crafted template-based or rule-based approaches'], ['trainable components', 'Compare', 'hand-crafted template-based or rule-based approaches']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13626373626373625, 0.12085769980506822, 0.128099173553719]
text: This paper outlines Plume as it currently exists and describes our detailed design for extending Plume to handle passives , relative clauses , and interrogatives in a general manner .
result: triple_list: [["Plume", "Hyponym_of", "it"]]
pred: [('Plume', 'Hyponym_of', 'it')]
trues: [['Plume', 'Used_for', 'passives'], ['Plume', 'Used_for', 'relative clauses'], ['Plume', 'Used_for', 'interrogatives'], ['passives', 'Conjunction', 'relative clauses'], ['relative clauses', 'Conjunction', 'interrogatives']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13596491228070176, 0.11969111969111969, 0.12731006160164268]
text: Recognition of proper nouns in Japanese text has been studied as a part of the more general problem of morphological analysis in Japanese text processing ( [ 1 ] [ 2 ] ) .
result: triple_list: [["Japanese text", "Used_for", "Recognition of proper nouns"]]
pred: [('Japanese text', 'Used_for', 'Recognition of proper nouns')]
trues: [['Recognition of proper nouns', 'Part_of', 'morphological analysis'], ['proper nouns', 'Part_of', 'Japanese text'], ['morphological analysis', 'Used_for', 'Japanese text processing']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13566739606126915, 0.11900191938579655, 0.1267893660531697]
text: Training instances are generated from experience and observation , and a variant of GOLEM is used to learn action models from these instances .
result: triple_list: [["Training instances", "Used_for", "experience and observation"], ["variant of GOLEM", "Used_for", "action models"]]
pred: [('Training instances', 'Used_for', 'experience and observation'), ('variant of GOLEM', 'Used_for', 'action models')]
trues: [['GOLEM', 'Used_for', 'action models']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13507625272331156, 0.11877394636015326, 0.12640163098878693]
text: The formalism 's intended usage is to relate expressions of natural languages to their associated semantics represented in a logical form language , or to their translates in another natural language ; in summary , we intend it to allow TAGs to be used beyond their role in syntax proper .
result: triple_list: [["logical form language", "Used_for", "TAGs"], ["it", "Used_for", "TAGs"]]
pred: [('logical form language', 'Used_for', 'TAGs'), ('it', 'Used_for', 'TAGs')]
trues: [['logical form language', 'Used_for', 'semantics'], ['TAGs', 'Used_for', 'syntax proper']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13449023861171366, 0.1183206106870229, 0.12588832487309645]
text: Both classifiers perform the best when conversational context and utterance features are combined with speaker 's gaze information .
result: triple_list: [["speaker 's gaze information", "Conjunction", "conversational context"], ["utterance features", "Conjunction", "speaker 's gaze information"]]
pred: [("speaker 's gaze information", 'Conjunction', 'conversational context'), ('utterance features', 'Conjunction', "speaker 's gaze information")]
trues: [['conversational context', 'Used_for', 'classifiers'], ['conversational context', 'Conjunction', 'utterance features'], ['utterance features', 'Used_for', 'classifiers'], ["speaker 's gaze information", 'Used_for', 'classifiers'], ["speaker 's gaze information", 'Conjunction', 'utterance features']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13390928725701945, 0.11720226843100189, 0.125]
text: On this challenging data set our system consistently demonstrated a nearly perfect recognition rate ( over 99.7 % on all three databases ) , significantly out-performing state-of-the-art commercial software and methods from the literature .
result: triple_list: [["system", "Evaluate_for", "recognition rate"], ["data set", "Used_for", "system"], ["recognition rate", "Evaluate_for", "recognition rate"], ["three databases", "Hyponym_of", "recognition rate"]]
pred: [('system', 'Evaluate_for', 'recognition rate'), ('data set', 'Used_for', 'system'), ('recognition rate', 'Evaluate_for', 'recognition rate'), ('three databases', 'Hyponym_of', 'recognition rate')]
trues: [['data set', 'Evaluate_for', 'system'], ['system', 'Compare', 'commercial software'], ['system', 'Compare', 'methods'], ['recognition rate', 'Evaluate_for', 'system'], ['commercial software', 'Conjunction', 'methods']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13276231263383298, 0.11610486891385768, 0.12387612387612389]
text: The subjects were given three minutes per extract to determine whether they believed the sample output to be an expert human translation or a machine translation .
result: The candidate relations for this text are:
Feature_of
The candidate entities for this text are:
human translation
sample output

triple_list: [["human translation", "Feature_of", "sample output"]]
pred: [('human translation', 'Feature_of', 'sample output')]
trues: [['expert human translation', 'Compare', 'machine translation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13247863247863248, 0.11588785046728972, 0.12362911266201396]
text: In the case of natural speech signals , the method is shown to have separation accuracy better than the state-of-the-art methods .
result: triple_list: [["natural speech signals", "Used_for", "method"]]
pred: [('natural speech signals', 'Used_for', 'method')]
trues: [['method', 'Used_for', 'natural speech signals'], ['method', 'Compare', 'methods'], ['separation accuracy', 'Evaluate_for', 'method'], ['separation accuracy', 'Evaluate_for', 'methods'], ['methods', 'Used_for', 'natural speech signals']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13219616204690832, 0.11481481481481481, 0.12289395441030723]
text: This allows us to use our method to act not only as a faster procedure for cascade evaluation , but also as a tool to perform efficient branch-and-bound object detection with nonlinear quality functions , in particular kernel-ized support vector machines .
result: triple_list: [["method", "Used_for", "cascade evaluation"], ["method", "Used_for", "branch-and-bound object detection"], ["nonlinear quality functions", "Part_of", "kernel-ized support vector machines"]]
pred: [('method', 'Used_for', 'cascade evaluation'), ('method', 'Used_for', 'branch-and-bound object detection'), ('nonlinear quality functions', 'Part_of', 'kernel-ized support vector machines')]
trues: [['method', 'Used_for', 'cascade evaluation'], ['method', 'Used_for', 'branch-and-bound object detection'], ['nonlinear quality functions', 'Used_for', 'branch-and-bound object detection'], ['kernel-ized support vector machines', 'Hyponym_of', 'nonlinear quality functions']]
metrics_sample: [0.6666666666666666, 0.5, 0.5714285714285715]
metrics_current: [0.13559322033898305, 0.11764705882352941, 0.12598425196850394]
text: Thus , the limitations of the automatic metrics used within MT are also discussed in this regard .
result: The candidate relations for this text are:
Evaluate_for
The candidate entities for this text are:
automatic metrics
MT

triple_list: [["automatic metrics", "Evaluate_for", "MT"]]
pred: [('automatic metrics', 'Evaluate_for', 'MT')]
trues: [['automatic metrics', 'Evaluate_for', 'MT']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.13742071881606766, 0.11926605504587157, 0.12770137524557956]
text: Our results show that MBR decoding can be used to tune statistical MT performance for specific loss functions .
result: triple_list: [["MBR decoding", "Used_for", "statistical MT performance"]]
pred: [('MBR decoding', 'Used_for', 'statistical MT performance')]
trues: [['MBR decoding', 'Used_for', 'statistical MT'], ['MBR decoding', 'Used_for', 'loss functions']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1371308016877637, 0.11882998171846434, 0.1273261508325171]
text: We propose a novel approach to associate objects across multiple PTZ cameras that can be used to perform camera handoff in wide-area surveillance scenarios .
result: triple_list: [["PTZ cameras", "Part_of", "approach"], ["approach", "Used_for", "objects"], ["approach", "Used_for", "camera handoff"], ["wide-area surveillance scenarios", "Used_for", "camera handoff"]]
pred: [('PTZ cameras', 'Part_of', 'approach'), ('approach', 'Used_for', 'objects'), ('approach', 'Used_for', 'camera handoff'), ('wide-area surveillance scenarios', 'Used_for', 'camera handoff')]
trues: [['approach', 'Used_for', 'camera handoff in wide-area surveillance scenarios']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13598326359832635, 0.11861313868613138, 0.1267056530214425]
text: The robust principal component analysis ( robust PCA ) problem has been considered in many machine learning applications , where the goal is to decompose the data matrix to a low rank part plus a sparse residual .
result: triple_list: [["machine learning applications", "Used_for", "robust PCA"]]
pred: [('machine learning applications', 'Used_for', 'robust PCA')]
trues: [['robust principal component analysis ( robust PCA ) problem', 'Used_for', 'machine learning applications'], ['low rank part', 'Part_of', 'data matrix'], ['low rank part', 'Conjunction', 'sparse residual'], ['sparse residual', 'Part_of', 'data matrix']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13569937369519833, 0.11775362318840579, 0.12609117361784675]
text: We have implemented a restricted domain parser called Plume .
result: triple_list: [["restricted domain parser", "Conjunction", "Plume"]]
pred: [('restricted domain parser', 'Conjunction', 'Plume')]
trues: [['Plume', 'Hyponym_of', 'restricted domain parser']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13541666666666666, 0.11754068716094032, 0.12584704743465633]
text: Starting from a DP-based solution to the traveling salesman problem , we present a novel technique to restrict the possible word reordering between source and target language in order to achieve an efficient search algorithm .
result: triple_list: [["DP-based solution", "Used_for", "traveling salesman problem"]]
pred: [('DP-based solution', 'Used_for', 'traveling salesman problem')]
trues: [['technique', 'Used_for', 'search algorithm']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13513513513513514, 0.11732851985559567, 0.12560386473429955]
text: This posterior encodes sparse se-lectional preferences between a head word and its dependents .
result: triple_list: [["posterior", "Part_of", "sparse se-lectional preferences"]]
pred: [('posterior', 'Part_of', 'sparse se-lectional preferences')]
trues: [['posterior', 'Used_for', 'sparse se-lectional preferences']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13485477178423236, 0.11711711711711711, 0.1253616200578592]
text: In particular , we make extensive use of Pustejovsky 's principles concerning the predicative information associated with nominals .
result: triple_list: [["Pustejovsky 's principles", "Part_of", "predicative information"]]
pred: [("Pustejovsky 's principles", 'Part_of', 'predicative information')]
trues: [['nominals', 'Feature_of', 'predicative information']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13457556935817805, 0.11690647482014388, 0.12512030798845042]
text: We use novel priors , generate sparse and dense detection maps and our results show high detection rate with rejection to pathological motion and occlusion .
result: triple_list: [["priors", "Used_for", "sparse and dense detection maps"], ["detection maps", "Used_for", "results"], ["rejection to pathological motion", "Compare", "occlusion"], ["occlusion", "Hyponym_of", "rejection to pathological motion"]]
pred: [('priors', 'Used_for', 'sparse and dense detection maps'), ('detection maps', 'Used_for', 'results'), ('rejection to pathological motion', 'Compare', 'occlusion'), ('occlusion', 'Hyponym_of', 'rejection to pathological motion')]
trues: [['priors', 'Used_for', 'sparse and dense detection maps'], ['pathological motion', 'Conjunction', 'occlusion']]
metrics_sample: [0.25, 0.5, 0.3333333333333333]
metrics_current: [0.13552361396303902, 0.11827956989247312, 0.12631578947368421]
text: The automated segmentation of images into semantically meaningful parts requires shape information since low-level feature analysis alone often fails to reach this goal .
result: triple_list: [["images", "Feature_of", "low-level feature analysis"], ["semantically meaningful parts", "Used_for", "automated segmentation of images into semantically meaningful parts"]]
pred: [('images', 'Feature_of', 'low-level feature analysis'), ('semantically meaningful parts', 'Used_for', 'automated segmentation of images into semantically meaningful parts')]
trues: [['images', 'Used_for', 'automated segmentation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13496932515337423, 0.11806797853309481, 0.12595419847328246]
text: We present results on addressee identification in four-participants face-to-face meetings using Bayesian Network and Naive Bayes classifiers .
result: triple_list: [["face-to-face meetings", "Evaluate_for", "addressee identification"], ["Bayesian Network", "Used_for", "addressee identification"], ["Naive Bayes classifiers", "Used_for", "addressee identification"]]
pred: [('face-to-face meetings', 'Evaluate_for', 'addressee identification'), ('Bayesian Network', 'Used_for', 'addressee identification'), ('Naive Bayes classifiers', 'Used_for', 'addressee identification')]
trues: [['Bayesian Network', 'Used_for', 'addressee identification in four-participants face-to-face meetings'], ['Naive Bayes classifiers', 'Used_for', 'addressee identification in four-participants face-to-face meetings'], ['Naive Bayes classifiers', 'Conjunction', 'Bayesian Network']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13414634146341464, 0.11743772241992882, 0.12523719165085387]
text: We further propose a parameter training algorithm for the present model based on a decision tree-based context clustering .
result: triple_list: [["decision tree-based context clustering", "Used_for", "parameter training algorithm"]]
pred: [('decision tree-based context clustering', 'Used_for', 'parameter training algorithm')]
trues: [['parameter training algorithm', 'Used_for', 'model'], ['decision tree-based context clustering', 'Used_for', 'parameter training algorithm']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.1359026369168357, 0.11879432624113476, 0.12677388836329234]
text: The proposed approach does not require a separate segmentation stage and is applicable to cluttered scenes .
result: triple_list: [["approach", "Used_for", "cluttered scenes"]]
pred: [('approach', 'Used_for', 'cluttered scenes')]
trues: [['approach', 'Used_for', 'cluttered scenes']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.13765182186234817, 0.12035398230088495, 0.1284230406043437]
text: A model-based approach to on-line cursive handwriting analysis and recognition is presented and evaluated .
result: The candidate relations for this text are:
Used_for
Evaluate_for
The candidate entities for this text are:
model-based approach
on-line cursive handwriting analysis and recognition
evaluation
on-line cursive handwriting analysis and recognition

triple_list: [["model-based approach", "Used_for", "on-line cursive handwriting analysis and recognition"], ["evaluation", "Evaluate_for", "on-line cursive handwriting analysis and recognition"]]
pred: [('model-based approach', 'Used_for', 'on-line cursive handwriting analysis and recognition'), ('evaluation', 'Evaluate_for', 'on-line cursive handwriting analysis and recognition')]
trues: [['model-based approach', 'Used_for', 'on-line cursive handwriting analysis and recognition']]
metrics_sample: [0.5, 1.0, 0.6666666666666666]
metrics_current: [0.13911290322580644, 0.12190812720848057, 0.12994350282485875]
text: We show how features that are imaged through a transparent object behave differently from those that are rigidly attached to the scene .
result: triple_list: [["features", "Compare", "those that are imaged through a transparent object"], ["those that are imaged through a transparent object", "Compare", "those that are rigidly attached to the scene"]]
pred: [('features', 'Compare', 'those that are imaged through a transparent object'), ('those that are imaged through a transparent object', 'Compare', 'those that are rigidly attached to the scene')]
trues: [['those', 'Compare', 'features']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13855421686746988, 0.12169312169312169, 0.1295774647887324]
text: The NCA is created statistically from a large corpus and recomposed under concept hierarchy constraints and frequency of occurrences .
result: triple_list: [["NCA", "Feature_of", "concept hierarchy constraints"], ["frequency of occurrences", "Conjunction", "concept hierarchy constraints"]]
pred: [('NCA', 'Feature_of', 'concept hierarchy constraints'), ('frequency of occurrences', 'Conjunction', 'concept hierarchy constraints')]
trues: [['concept hierarchy constraints', 'Used_for', 'NCA'], ['frequency of occurrences', 'Used_for', 'NCA']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.138, 0.12126537785588752, 0.12909260991580918]
text: During normal tracking conditions when the object is visible from frame to frame , local optimization is used to track the local mode of the similarity measure in a parameter space of translation , rotation and scale .
result: triple_list: [["local optimization", "Used_for", "object"]]
pred: [('local optimization', 'Used_for', 'object')]
trues: [['local optimization', 'Used_for', 'local mode of the similarity measure'], ['parameter space of translation , rotation and scale', 'Used_for', 'local mode of the similarity measure']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1377245508982036, 0.12084063047285463, 0.1287313432835821]
text: Multi-view constraints associated with groups of patches are combined with a normalized representation of their appearance to guide matching and reconstruction , allowing the acquisition of true three-dimensional affine and Euclidean models from multiple images and their recognition in a single photograph taken from an arbitrary viewpoint .
result: triple_list: [["Multi-view constraints", "Conjunction", "normalized representation of their appearance"], ["matching", "Used_for", "recognition"], ["photograph", "Used_for", "recognition"]]
pred: [('Multi-view constraints', 'Conjunction', 'normalized representation of their appearance'), ('matching', 'Used_for', 'recognition'), ('photograph', 'Used_for', 'recognition')]
trues: [['Multi-view constraints', 'Conjunction', 'normalized representation'], ['Multi-view constraints', 'Used_for', 'matching'], ['Multi-view constraints', 'Used_for', 'reconstruction'], ['normalized representation', 'Used_for', 'matching'], ['normalized representation', 'Used_for', 'reconstruction'], ['matching', 'Conjunction', 'reconstruction'], ['images', 'Used_for', 'acquisition of true three-dimensional affine and Euclidean models']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13690476190476192, 0.11937716262975778, 0.12754158964879853]
text: Bayesian inference then samples the rules , disambiguating and combining them to create complex tree structures that maximize a discriminative model 's posterior on a target unlabeled corpus .
result: triple_list: [["rules", "Part_of", "complex tree structures"], ["discriminative model 's posterior", "Feature_of", "unlabeled corpus"]]
pred: [('rules', 'Part_of', 'complex tree structures'), ("discriminative model 's posterior", 'Feature_of', 'unlabeled corpus')]
trues: [['Bayesian inference', 'Used_for', 'rules'], ['them', 'Used_for', 'complex tree structures'], ['complex tree structures', 'Used_for', "discriminative model 's posterior"], ['unlabeled corpus', 'Used_for', "discriminative model 's posterior"]]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13636363636363635, 0.11855670103092783, 0.1268382352941176]
text: We show how this can efficiently be combined with random-projection based methods for 2 NN search , such as locality-sensitive hashing ( LSH ) or random projection trees .
result: The candidate relations for this text are:
Used_for
The candidate entities for this text are:
random-projection based methods
2 NN search

triple_list: [["random-projection based methods", "Used_for", "2 NN search"]]
pred: [('random-projection based methods', 'Used_for', '2 NN search')]
trues: [['this', 'Conjunction', 'random-projection based methods'], ['random-projection based methods', 'Used_for', 'NN search'], ['locality-sensitive hashing ( LSH )', 'Hyponym_of', 'random-projection based methods'], ['locality-sensitive hashing ( LSH )', 'Conjunction', 'random projection trees'], ['random projection trees', 'Hyponym_of', 'random-projection based methods']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13609467455621302, 0.11754684838160136, 0.12614259597806216]
text: The description has been implemented using the PC-KIMMO environment ( Antworth , 1990 ) and is based on a root word lexicon of about 23,000 roots words .
result: triple_list: [["PC-KIMMO environment", "Used_for", "description"]]
pred: [('PC-KIMMO environment', 'Used_for', 'description')]
trues: [['PC-KIMMO environment', 'Used_for', 'description'], ['root word lexicon', 'Used_for', 'description']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.1377952755905512, 0.11884550084889643, 0.12762078395624432]
text: The result is a discrete motor control representation of the continuous pen motion , via the quantized levels of the model parameters .
result: triple_list: [["discrete motor control representation of the continuous pen motion", "Used_for", "model parameters"]]
pred: [('discrete motor control representation of the continuous pen motion', 'Used_for', 'model parameters')]
trues: [['discrete motor control representation', 'Used_for', 'continuous pen motion']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.137524557956778, 0.11864406779661017, 0.12738853503184713]
text: At the core of the externally digital architecture is a high-density , low-power analog array performing binary-binary partial matrix-vector multiplication .
result: triple_list: [["analog array", "Used_for", "binary-binary partial matrix-vector multiplication"]]
pred: [('analog array', 'Used_for', 'binary-binary partial matrix-vector multiplication')]
trues: [['high-density , low-power analog array', 'Part_of', 'externally digital architecture'], ['binary-binary partial matrix-vector multiplication', 'Used_for', 'high-density , low-power analog array']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13725490196078433, 0.11824324324324324, 0.12704174228675139]
text: The result theoretically justifies the effectiveness of features in robust PCA .
result: triple_list: [["features", "Used_for", "robust PCA"]]
pred: [('features', 'Used_for', 'robust PCA')]
trues: [['features', 'Feature_of', 'robust PCA']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.136986301369863, 0.11804384485666104, 0.12681159420289856]
text: The model is evaluated on English and Czech newspaper texts , and is then validated on French broadcast news transcriptions .
result: The candidate relations for this text are:
Evaluate_for
Evaluate_for
Evaluate_for
Evaluate_for
The candidate entities for this text are:
English and Czech newspaper texts
model
Czech newspaper texts
English
French broadcast news transcriptions
model

triple_list: [["English and Czech newspaper texts", "Evaluate_for", "model"], ["Czech newspaper texts", "Evaluate_for", "English"], ["French broadcast news transcriptions", "Evaluate_for", "model"]]
pred: [('English and Czech newspaper texts', 'Evaluate_for', 'model'), ('Czech newspaper texts', 'Evaluate_for', 'English'), ('French broadcast news transcriptions', 'Evaluate_for', 'model')]
trues: [['English and Czech newspaper texts', 'Evaluate_for', 'model'], ['French broadcast news transcriptions', 'Evaluate_for', 'model']]
metrics_sample: [0.6666666666666666, 1.0, 0.8]
metrics_current: [0.14007782101167315, 0.12100840336134454, 0.12984670874661855]
text: In the second half of the paper , we report a laboratory study using the Wizard of Oz technique to identify NL requirements for carrying out this task .
result: triple_list: [["task", "Feature_of", "NL requirements"]]
pred: [('task', 'Feature_of', 'NL requirements')]
trues: [['Wizard of Oz technique', 'Used_for', 'NL requirements'], ['Wizard of Oz technique', 'Used_for', 'task']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13980582524271845, 0.12060301507537688, 0.12949640287769784]
text: We present a novel model-based approach to recover the shapes and the poses of transparent objects from known motion .
result: triple_list: [["model-based approach", "Used_for", "shapes and the poses of transparent objects"], ["known motion", "Used_for", "model-based approach"]]
pred: [('model-based approach', 'Used_for', 'shapes and the poses of transparent objects'), ('known motion', 'Used_for', 'model-based approach')]
trues: [['model-based approach', 'Used_for', 'shapes and the poses of transparent objects'], ['known motion', 'Used_for', 'shapes and the poses of transparent objects']]
metrics_sample: [0.5, 0.5, 0.5]
metrics_current: [0.14119922630560927, 0.12186978297161936, 0.13082437275985662]
text: We validate this new method on nine standard person re-identification datasets including two large scale Market-1501 and CUHK03 datasets and show that we improve upon the current state-of-the-art methods on all of them .
result: triple_list: [["Market-1501 and CUHK03 datasets", "Evaluate_for", "methods"], ["them", "Compare", "current state-of-the-art methods"]]
pred: [('Market-1501 and CUHK03 datasets', 'Evaluate_for', 'methods'), ('them', 'Compare', 'current state-of-the-art methods')]
trues: [['person re-identification datasets', 'Evaluate_for', 'method'], ['scale Market-1501', 'Hyponym_of', 'person re-identification datasets'], ['CUHK03 datasets', 'Hyponym_of', 'person re-identification datasets'], ['CUHK03 datasets', 'Conjunction', 'scale Market-1501']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14065510597302505, 0.12106135986733002, 0.13012477718360071]
text: A bio-inspired model for an analog programmable array processor ( APAP ) , based on studies on the vertebrate retina , has permitted the realization of complex programmable spatio-temporal dynamics in VLSI .
result: triple_list: [["bio-inspired model", "Used_for", "analog programmable array processor ( APAP )"]]
pred: [('bio-inspired model', 'Used_for', 'analog programmable array processor ( APAP )')]
trues: [['bio-inspired model', 'Used_for', 'analog programmable array processor ( APAP )'], ['bio-inspired model', 'Used_for', 'complex programmable spatio-temporal dynamics'], ['vertebrate retina', 'Used_for', 'bio-inspired model'], ['complex programmable spatio-temporal dynamics', 'Feature_of', 'VLSI']]
metrics_sample: [1.0, 0.25, 0.4]
metrics_current: [0.1423076923076923, 0.12191103789126853, 0.13132209405501333]
text: Machine transliteration/back-transliteration plays an important role in many multilingual speech and language applications .
result: triple_list: [["Machine transliteration/back-transliteration", "Used_for", "multilingual speech and language applications"]]
pred: [('Machine transliteration/back-transliteration', 'Used_for', 'multilingual speech and language applications')]
trues: [['Machine transliteration/back-transliteration', 'Used_for', 'multilingual speech and language applications']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.14395393474088292, 0.12335526315789473, 0.1328609388839681]
text: In this paper , we propose a new method for the modeling and subtraction of such scenes .
result: triple_list: [["method", "Used_for", "modeling and subtraction of such scenes"]]
pred: [('method', 'Used_for', 'modeling and subtraction of such scenes')]
trues: [['method', 'Used_for', 'modeling and subtraction of such scenes']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.14559386973180077, 0.12479474548440066, 0.134394341290893]
text: Establishing a `` best '' correspondence between the '' UNL-tree + L0 '' and the '' MS-L0 structure '' , a lattice , may be done using the dictionary and trying to align the tree and the selected trajectory with as few crossing liaisons as possible .
result: triple_list: [["'' UNL-tree + L0 ''", "Used_for", "correspondence"], ["`` MS-L0 structure ''", "Used_for", "correspondence"]]
pred: [("'' UNL-tree + L0 ''", 'Used_for', 'correspondence'), ("`` MS-L0 structure ''", 'Used_for', 'correspondence')]
trues: [['UNL-tree + L0', 'Conjunction', 'MS-L0 structure'], ['dictionary', 'Used_for', 'lattice']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1450381679389313, 0.12438625204582651, 0.13392070484581498]
text: Our experiments on real data sets show that the resulting detector is more robust to the choice of training examples , and substantially improves both linear and kernel SVM when trained on 10 positive and 10 negative examples .
result: triple_list: [["detector", "Used_for", "real data sets"], ["training examples", "Feature_of", "detector"], ["linear and kernel SVM", "Evaluate_for", "detector"], ["positive and 10 negative examples", "Evaluate_for", "training examples"]]
pred: [('detector', 'Used_for', 'real data sets'), ('training examples', 'Feature_of', 'detector'), ('linear and kernel SVM', 'Evaluate_for', 'detector'), ('positive and 10 negative examples', 'Evaluate_for', 'training examples')]
trues: [['real data sets', 'Evaluate_for', 'detector'], ['detector', 'Compare', 'linear and kernel SVM']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14393939393939395, 0.12398042414355628, 0.13321647677475898]
text: Under this framework , a joint source-channel transliteration model , also called n-gram transliteration model ( n-gram TM ) , is further proposed to model the transliteration process .
result: triple_list: [["source-channel transliteration model", "Used_for", "joint source-channel transliteration model"], ["joint source-channel transliteration model", "Used_for", "n-gram transliteration model ( n-gram TM )"]]
pred: [('source-channel transliteration model', 'Used_for', 'joint source-channel transliteration model'), ('joint source-channel transliteration model', 'Used_for', 'n-gram transliteration model ( n-gram TM )')]
trues: [['framework', 'Used_for', 'joint source-channel transliteration model'], ['n-gram transliteration model ( n-gram TM )', 'Used_for', 'transliteration process']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14339622641509434, 0.12357723577235773, 0.1327510917030568]
text: It is demonstrated qualitatively and quantitatively on a dataset of scenes and is suitable for current work in unsupervised object discovery without top-down knowledge .
result: triple_list: [["dataset of scenes", "Used_for", "unsupervised object discovery"]]
pred: [('dataset of scenes', 'Used_for', 'unsupervised object discovery')]
trues: [['It', 'Used_for', 'unsupervised object discovery'], ['dataset of scenes', 'Evaluate_for', 'It']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1431261770244821, 0.12317666126418152, 0.13240418118466898]
text: The resulting logical expression is then transformed by a planning algorithm into efficient Prolog , cf. query optimisation in a relational database .
result: triple_list: [["logical expression", "Used_for", "planning algorithm"], ["Prolog", "Compare", "relational database"]]
pred: [('logical expression', 'Used_for', 'planning algorithm'), ('Prolog', 'Compare', 'relational database')]
trues: [['planning algorithm', 'Used_for', 'logical expression'], ['relational database', 'Used_for', 'query optimisation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1425891181988743, 0.12277867528271405, 0.13194444444444442]
text: In this theory , discourse structure is composed of three separate but interrelated components : the structure of the sequence of utterances ( called the linguistic structure ) , a structure of purposes ( called the intentional structure ) , and the state of focus of attention ( called the attentional state ) .
result: triple_list: [["discourse structure", "Part_of", "components"], ["structure of the sequence of utterances", "Part_of", "components"], ["structure of purposes", "Part_of", "components"], ["structure of purposes", "Conjunction", "the intentional structure"], ["the intentional structure", "Part_of", "components"], ["the state of focus of attention", "Part_of", "components"], ["the state of focus of attention", "Conjunction", "the attentional state"]]
pred: [('discourse structure', 'Part_of', 'components'), ('structure of the sequence of utterances', 'Part_of', 'components'), ('structure of purposes', 'Part_of', 'components'), ('structure of purposes', 'Conjunction', 'the intentional structure'), ('the intentional structure', 'Part_of', 'components'), ('the state of focus of attention', 'Part_of', 'components'), ('the state of focus of attention', 'Conjunction', 'the attentional state')]
trues: [['components', 'Part_of', 'discourse structure'], ['linguistic structure', 'Part_of', 'components'], ['linguistic structure', 'Conjunction', 'intentional structure'], ['intentional structure', 'Part_of', 'components'], ['intentional structure', 'Conjunction', 'attentional state'], ['attentional state', 'Part_of', 'components']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14074074074074075, 0.1216, 0.13047210300429185]
text: We also derive an efficient non-linear extension of WARCA by using the kernel trick .
result: triple_list: [["non-linear extension of WARCA", "Used_for", "kernel trick"]]
pred: [('non-linear extension of WARCA', 'Used_for', 'kernel trick')]
trues: [['kernel trick', 'Used_for', 'non-linear extension of WARCA']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14048059149722736, 0.12140575079872204, 0.13024850042844902]
text: This work presents an automated technique for detecting reflections in image sequences by analyzing motion trajectories of feature points .
result: triple_list: [["automated technique", "Used_for", "detecting reflections in image sequences"]]
pred: [('automated technique', 'Used_for', 'detecting reflections in image sequences')]
trues: [['technique', 'Used_for', 'detecting reflections in image sequences'], ['motion trajectories', 'Used_for', 'technique'], ['feature points', 'Feature_of', 'motion trajectories']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14022140221402213, 0.12082670906200318, 0.12980358667805292]
text: This paper presents the results of automatically inducing a Combinatory Categorial Grammar ( CCG ) lexicon from a Turkish dependency treebank .
result: triple_list: [["Turkish dependency treebank", "Used_for", "Combinatory Categorial Grammar ( CCG ) lexicon"]]
pred: [('Turkish dependency treebank', 'Used_for', 'Combinatory Categorial Grammar ( CCG ) lexicon')]
trues: [['Combinatory Categorial Grammar ( CCG ) lexicon', 'Part_of', 'Turkish dependency treebank']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13996316758747698, 0.12063492063492064, 0.1295822676896846]
text: We investigate the problem of learning to predict moves in the board game of Go from game records of expert players .
result: triple_list: [["Go", "Used_for", "learning to predict moves"]]
pred: [('Go', 'Used_for', 'learning to predict moves')]
trues: [['game records of expert players', 'Used_for', 'board game of Go']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13970588235294118, 0.12044374009508717, 0.12936170212765954]
text: However , they provide no guarantee of being more efficient than exhaustive search .
result: triple_list: [["they", "Compare", "exhaustive search"]]
pred: [('they', 'Compare', 'exhaustive search')]
trues: [['they', 'Compare', 'exhaustive search']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.14128440366972478, 0.12183544303797468, 0.13084112149532712]
text: We show that the trainable sentence planner performs better than the rule-based systems and the baselines , and as well as the hand-crafted system .
result: triple_list: [["trainable sentence planner", "Compare", "rule-based systems"], ["trainable sentence planner", "Compare", "baselines"], ["rule-based systems", "Hyponym_of", "baselines"], ["rule-based systems", "Compare", "hand-crafted system"], ["baselines", "Hyponym_of", "hand-crafted system"]]
pred: [('trainable sentence planner', 'Compare', 'rule-based systems'), ('trainable sentence planner', 'Compare', 'baselines'), ('rule-based systems', 'Hyponym_of', 'baselines'), ('rule-based systems', 'Compare', 'hand-crafted system'), ('baselines', 'Hyponym_of', 'hand-crafted system')]
trues: [['trainable sentence planner', 'Compare', 'rule-based systems'], ['trainable sentence planner', 'Compare', 'baselines'], ['trainable sentence planner', 'Compare', 'hand-crafted system'], ['rule-based systems', 'Conjunction', 'baselines'], ['baselines', 'Conjunction', 'hand-crafted system']]
metrics_sample: [0.4, 0.4, 0.4000000000000001]
metrics_current: [0.14363636363636365, 0.12401883830455258, 0.13310867733782644]
text: Our approach outperforms state-of-the-art trackers on the VIVID benchmark datasets .
result: triple_list: [["approach", "Evaluate_for", "VIVID benchmark datasets"], ["state-of-the-art trackers", "Compare", "approach"], ["VIVID benchmark datasets", "Evaluate_for", "state-of-the-art trackers"]]
pred: [('approach', 'Evaluate_for', 'VIVID benchmark datasets'), ('state-of-the-art trackers', 'Compare', 'approach'), ('VIVID benchmark datasets', 'Evaluate_for', 'state-of-the-art trackers')]
trues: [['state-of-the-art trackers', 'Compare', 'approach'], ['VIVID benchmark datasets', 'Evaluate_for', 'approach'], ['VIVID benchmark datasets', 'Evaluate_for', 'state-of-the-art trackers']]
metrics_sample: [0.6666666666666666, 0.6666666666666666, 0.6666666666666666]
metrics_current: [0.14647377938517178, 0.1265625, 0.1357921207041073]
text: It would also be effective as a move selector and move sorter for game tree search and as a training tool for Go players .
result: triple_list: [["It", "Used_for", "move selector"], ["It", "Conjunction", "move sorter"], ["It", "Hyponym_of", "game tree search"], ["It", "Hyponym_of", "training tool"], ["Go players", "Conjunction", "training tool"]]
pred: [('It', 'Used_for', 'move selector'), ('It', 'Conjunction', 'move sorter'), ('It', 'Hyponym_of', 'game tree search'), ('It', 'Hyponym_of', 'training tool'), ('Go players', 'Conjunction', 'training tool')]
trues: [['It', 'Used_for', 'move selector'], ['It', 'Used_for', 'move sorter'], ['It', 'Used_for', 'training tool'], ['move selector', 'Conjunction', 'move sorter'], ['move selector', 'Used_for', 'game tree search'], ['move sorter', 'Used_for', 'game tree search'], ['training tool', 'Used_for', 'Go players']]
metrics_sample: [0.2, 0.14285714285714285, 0.16666666666666666]
metrics_current: [0.14695340501792115, 0.1267387944358578, 0.13609958506224065]
text: In addition to the high accuracy of the model , the use of smoothing in an unlexicalized parser allows us to better examine the interplay between smoothing and parsing results .
result: triple_list: [["smoothing", "Part_of", "unlexicalized parser"], ["smoothing", "Conjunction", "parsing results"], ["smoothing", "Conjunction", "interplay"]]
pred: [('smoothing', 'Part_of', 'unlexicalized parser'), ('smoothing', 'Conjunction', 'parsing results'), ('smoothing', 'Conjunction', 'interplay')]
trues: [['accuracy', 'Evaluate_for', 'model'], ['smoothing', 'Used_for', 'unlexicalized parser']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14616755793226383, 0.1263482280431433, 0.13553719008264462]
text: Given an object model and a black-box measure of similarity between the model and candidate targets , we consider visual object tracking as a numerical optimization problem .
result: triple_list: [["object model", "Used_for", "visual object tracking"]]
pred: [('object model', 'Used_for', 'visual object tracking')]
trues: [['numerical optimization problem', 'Used_for', 'visual object tracking']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14590747330960854, 0.12615384615384614, 0.1353135313531353]
text: To a large extent , these statistics reflect semantic constraints and thus are used to disambiguate anaphora references and syntactic ambiguities .
result: triple_list: [["statistics", "Used_for", "semantic constraints"], ["semantic constraints", "Used_for", "disambiguate anaphora references"], ["syntactic ambiguities", "Used_for", "disambiguate anaphora references"]]
pred: [('statistics', 'Used_for', 'semantic constraints'), ('semantic constraints', 'Used_for', 'disambiguate anaphora references'), ('syntactic ambiguities', 'Used_for', 'disambiguate anaphora references')]
trues: [['semantic constraints', 'Used_for', 'anaphora references'], ['semantic constraints', 'Used_for', 'syntactic ambiguities'], ['anaphora references', 'Conjunction', 'syntactic ambiguities']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14513274336283186, 0.12557427258805512, 0.1346469622331691]
text: We conclude that previous approaches have neglected to evaluate systems in the context of their use , e.g. solving a task requiring data retrieval .
result: triple_list: [["approaches", "Used_for", "systems"]]
pred: [('approaches', 'Used_for', 'systems')]
trues: [['approaches', 'Evaluate_for', 'systems'], ['systems', 'Used_for', 'task'], ['data retrieval', 'Part_of', 'task']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14487632508833923, 0.125, 0.13420621931260227]
text: We present a new method for detecting interest points using histogram information .
result: triple_list: [["histogram information", "Used_for", "method"]]
pred: [('histogram information', 'Used_for', 'method')]
trues: [['method', 'Used_for', 'detecting interest points'], ['histogram information', 'Used_for', 'detecting interest points']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14462081128747795, 0.12462006079027356, 0.1338775510204082]
text: A critical step in encoding sound for neuronal processing occurs when the analog pressure wave is coded into discrete nerve-action potentials .
result: triple_list: [["sound", "Used_for", "neuronal processing"]]
pred: [('sound', 'Used_for', 'neuronal processing')]
trues: [['encoding sound', 'Used_for', 'neuronal processing'], ['discrete nerve-action potentials', 'Used_for', 'analog pressure wave']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1443661971830986, 0.12424242424242424, 0.13355048859934854]
text: We evaluate the demands that task dialogues collected using this technique , place upon a prototype Natural Language system .
result: triple_list: [["task dialogues", "Used_for", "Natural Language system"]]
pred: [('task dialogues', 'Used_for', 'Natural Language system')]
trues: [['task dialogues', 'Used_for', 'prototype Natural Language system'], ['technique', 'Used_for', 'task dialogues']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14411247803163443, 0.12386706948640483, 0.1332250203086921]
text: GLOSSER is designed to support reading and learning to read in a foreign language .
result: triple_list: [["GLOSSER", "Used_for", "reading and learning to read in a foreign language"]]
pred: [('GLOSSER', 'Used_for', 'reading and learning to read in a foreign language')]
trues: [['GLOSSER', 'Used_for', 'reading and learning']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14385964912280702, 0.12368024132730016, 0.1330089213300892]
text: In the experiments , we used a variety of methods for preparing a segmented corpus and compared the language models by their speech recognition accuracies .
result: triple_list: [["segmented corpus", "Used_for", "methods"]]
pred: [('segmented corpus', 'Used_for', 'methods')]
trues: [['methods', 'Used_for', 'preparing a segmented corpus'], ['speech recognition accuracies', 'Evaluate_for', 'language models']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1436077057793345, 0.12330827067669173, 0.13268608414239483]
text: This model is meant to account for productive rules of interpretation which are inferred from the morpho-syntactic and semantic characteristics of the nominal constituents .
result: triple_list: [["model", "Used_for", "interpretation"]]
pred: [('model', 'Used_for', 'interpretation')]
trues: [['model', 'Used_for', 'productive rules of interpretation'], ['morpho-syntactic and semantic characteristics', 'Used_for', 'productive rules of interpretation'], ['morpho-syntactic and semantic characteristics', 'Feature_of', 'nominal constituents']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14335664335664336, 0.12275449101796407, 0.13225806451612904]
text: Multi-layer perceptrons ( MLPs ) performed much better than standard Gaussian mixture models ( GMMs ) for both our ANF-based and ON-based auditory features .
result: triple_list: [["Multi-layer perceptrons ( MLPs )", "Compare", "Gaussian mixture models ( GMMs )"], ["ANF-based and ON-based auditory features", "Used_for", "Multi-layer perceptrons ( MLPs )"], ["ANF-based and ON-based auditory features", "Used_for", "Gaussian mixture models ( GMMs )"]]
pred: [('Multi-layer perceptrons ( MLPs )', 'Compare', 'Gaussian mixture models ( GMMs )'), ('ANF-based and ON-based auditory features', 'Used_for', 'Multi-layer perceptrons ( MLPs )'), ('ANF-based and ON-based auditory features', 'Used_for', 'Gaussian mixture models ( GMMs )')]
trues: [['Multi-layer perceptrons ( MLPs )', 'Compare', 'Gaussian mixture models ( GMMs )'], ['Multi-layer perceptrons ( MLPs )', 'Used_for', 'ANF-based and ON-based auditory features'], ['Gaussian mixture models ( GMMs )', 'Used_for', 'ANF-based and ON-based auditory features']]
metrics_sample: [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]
metrics_current: [0.1443478260869565, 0.12369597615499255, 0.13322632423756017]
text: We present a novel method for discovering parallel sentences in comparable , non-parallel corpora .
result: triple_list: [["method", "Used_for", "parallel sentences"]]
pred: [('method', 'Used_for', 'parallel sentences')]
trues: [['method', 'Used_for', 'discovering parallel sentences'], ['comparable , non-parallel corpora', 'Used_for', 'discovering parallel sentences']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1440972222222222, 0.12332838038632987, 0.13290632506004804]
text: Extended CF grammars ( grammars with regular expressions at the right hand side ) can be parsed with a simple modification of the LR-parser for normal CF grammars .
result: triple_list: [["Extended CF grammars ( grammars with regular expressions at the right hand side )", "Used_for", "LR-parser"], ["LR-parser", "Used_for", "normal CF grammars"]]
pred: [('Extended CF grammars ( grammars with regular expressions at the right hand side )', 'Used_for', 'LR-parser'), ('LR-parser', 'Used_for', 'normal CF grammars')]
trues: [['regular expressions', 'Feature_of', 'grammars'], ['LR-parser', 'Used_for', 'Extended CF grammars'], ['LR-parser', 'Used_for', 'CF grammars']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14359861591695502, 0.1227810650887574, 0.13237639553429026]
text: Moreover , a cost zero solution always exists and can only be excluded by hard budget constraints .
result: triple_list: [["cost zero solution", "Used_for", "hard budget constraints"]]
pred: [('cost zero solution', 'Used_for', 'hard budget constraints')]
trues: [['hard budget constraints', 'Used_for', 'cost zero solution']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14335060449050085, 0.12259970457902511, 0.1321656050955414]
text: Translations are produced by means of a beam-search decoder .
result: triple_list: [["beam-search decoder", "Used_for", "Translations"]]
pred: [('beam-search decoder', 'Used_for', 'Translations')]
trues: [['beam-search decoder', 'Used_for', 'Translations']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.14482758620689656, 0.12389380530973451, 0.13354531001589823]
text: The distinction among these components is essential to provide an adequate explanation of such discourse phenomena as cue phrases , referring expressions , and interruptions .
result: triple_list: [["components", "Part_of", "discourse phenomena"], ["cue phrases", "Part_of", "components"], ["referring expressions", "Part_of", "components"], ["interruptions", "Part_of", "components"]]
pred: [('components', 'Part_of', 'discourse phenomena'), ('cue phrases', 'Part_of', 'components'), ('referring expressions', 'Part_of', 'components'), ('interruptions', 'Part_of', 'components')]
trues: [['cue phrases', 'Hyponym_of', 'discourse phenomena'], ['cue phrases', 'Conjunction', 'referring expressions'], ['referring expressions', 'Hyponym_of', 'discourse phenomena'], ['referring expressions', 'Conjunction', 'interruptions'], ['interruptions', 'Hyponym_of', 'discourse phenomena']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14383561643835616, 0.12298682284040996, 0.13259668508287292]
text: We show that various features based on the structure of email-threads can be used to improve upon lexical similarity of discourse segments for question-answer pairing .
result: triple_list: [["features", "Used_for", "email-threads"]]
pred: [('features', 'Used_for', 'email-threads')]
trues: [['features', 'Used_for', 'lexical similarity'], ['features', 'Used_for', 'question-answer pairing'], ['structure of email-threads', 'Used_for', 'features'], ['lexical similarity', 'Feature_of', 'discourse segments']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14358974358974358, 0.1222707423580786, 0.1320754716981132]
text: We propose a novel metric learning formulation called Weighted Approximate Rank Component Analysis ( WARCA ) .
result: triple_list: [["Weighted Approximate Rank Component Analysis ( WARCA )", "Used_for", "metric learning"]]
pred: [('Weighted Approximate Rank Component Analysis ( WARCA )', 'Used_for', 'metric learning')]
trues: [['Weighted Approximate Rank Component Analysis ( WARCA )', 'Hyponym_of', 'metric learning formulation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14334470989761092, 0.12209302325581395, 0.13186813186813184]
text: In this work , we study how Convolutional Neural Networks ( CNN ) architectures can be adapted to the task of simultaneous object recognition and pose estimation .
result: The candidate relations for this text are:
Used_for
Used_for
Used_for
Conjunction
The candidate entities for this text are:
Convolutional Neural Networks ( CNN )
task of simultaneous object recognition and pose estimation
Convolutional Neural Networks ( CNN )
simultaneous object recognition
Convolutional Neural Networks ( CNN )
pose estimation
simultaneous object recognition
pose estimation

triple_list: [["Convolutional Neural Networks ( CNN )", "Used_for", "task of simultaneous object recognition and pose estimation"], ["Convolutional Neural Networks ( CNN )", "Used_for", "simultaneous object recognition"], ["Convolutional Neural Networks ( CNN )", "Used_for", "pose estimation"], ["simultaneous object recognition", "Conjunction", "pose estimation"]]
pred: [('Convolutional Neural Networks ( CNN )', 'Used_for', 'task of simultaneous object recognition and pose estimation'), ('Convolutional Neural Networks ( CNN )', 'Used_for', 'simultaneous object recognition'), ('Convolutional Neural Networks ( CNN )', 'Used_for', 'pose estimation'), ('simultaneous object recognition', 'Conjunction', 'pose estimation')]
trues: [['Convolutional Neural Networks ( CNN ) architectures', 'Used_for', 'object recognition'], ['Convolutional Neural Networks ( CNN ) architectures', 'Used_for', 'pose estimation'], ['object recognition', 'Conjunction', 'pose estimation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1423728813559322, 0.12156295224312591, 0.13114754098360654]
text: Background modeling is an important component of many vision systems .
result: triple_list: [["Background modeling", "Part_of", "vision systems"]]
pred: [('Background modeling', 'Part_of', 'vision systems')]
trues: [['Background modeling', 'Part_of', 'vision systems']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.14382402707275804, 0.12283236994219653, 0.13250194855806702]
text: In this paper , a novel framework for machine transliteration/backtransliteration that allows us to carry out direct orthographical mapping ( DOM ) between two different languages is presented .
result: triple_list: [["framework", "Used_for", "machine transliteration/backtransliteration"]]
pred: [('framework', 'Used_for', 'machine transliteration/backtransliteration')]
trues: [['framework', 'Used_for', 'machine transliteration/backtransliteration'], ['machine transliteration/backtransliteration', 'Used_for', 'direct orthographical mapping ( DOM )']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.14527027027027026, 0.1239193083573487, 0.13374805598755832]
text: In practice , the current deep embedding methods use the Euclidean distance for the training and test .
result: triple_list: [["Euclidean distance", "Used_for", "training and test"], ["Euclidean distance", "Conjunction", "deep embedding methods"]]
pred: [('Euclidean distance', 'Used_for', 'training and test'), ('Euclidean distance', 'Conjunction', 'deep embedding methods')]
trues: [['Euclidean distance', 'Used_for', 'deep embedding methods']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1447811447811448, 0.1237410071942446, 0.13343677269200932]
text: Our approach is based on the iterative deformation of a 3 -- D surface mesh to minimize an objective function .
result: triple_list: [["iterative deformation of a 3 -- D surface mesh", "Used_for", "objective function"]]
pred: [('iterative deformation of a 3 -- D surface mesh', 'Used_for', 'objective function')]
trues: [['iterative deformation of a 3 -- D surface mesh', 'Used_for', 'approach'], ['iterative deformation of a 3 -- D surface mesh', 'Used_for', 'objective function']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.146218487394958, 0.12482065997130559, 0.1346749226006192]
text: MINPRAN , a new robust operator , nds good ts in data sets where more than 50 % of the points are outliers .
result: triple_list: [["MINPRAN", "Used_for", "robust operator"]]
pred: [('MINPRAN', 'Used_for', 'robust operator')]
trues: [['MINPRAN', 'Hyponym_of', 'robust operator']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14597315436241612, 0.12464183381088825, 0.13446676970633695]
text: This paper investigates the utility of applying standard MT evaluation methods ( BLEU , NIST , WER and PER ) to building classifiers to predict semantic equivalence and entailment .
result: triple_list: [["BLEU", "Used_for", "MT evaluation methods"], ["BLEU", "Compare", "NIST"], ["NIST", "Compare", "WER"], ["WER", "Used_for", "MT evaluation methods"], ["WER", "Compare", "PER"], ["PER", "Used_for", "MT evaluation methods"], ["classifiers", "Used_for", "semantic equivalence"], ["classifiers", "Used_for", "entailment"]]
pred: [('BLEU', 'Used_for', 'MT evaluation methods'), ('BLEU', 'Compare', 'NIST'), ('NIST', 'Compare', 'WER'), ('WER', 'Used_for', 'MT evaluation methods'), ('WER', 'Compare', 'PER'), ('PER', 'Used_for', 'MT evaluation methods'), ('classifiers', 'Used_for', 'semantic equivalence'), ('classifiers', 'Used_for', 'entailment')]
trues: [['MT evaluation methods', 'Used_for', 'classifiers'], ['BLEU', 'Hyponym_of', 'MT evaluation methods'], ['BLEU', 'Conjunction', 'NIST'], ['NIST', 'Hyponym_of', 'MT evaluation methods'], ['NIST', 'Conjunction', 'WER'], ['WER', 'Hyponym_of', 'MT evaluation methods'], ['WER', 'Conjunction', 'PER'], ['PER', 'Hyponym_of', 'MT evaluation methods'], ['classifiers', 'Used_for', 'semantic equivalence'], ['classifiers', 'Used_for', 'entailment'], ['semantic equivalence', 'Conjunction', 'entailment']]
metrics_sample: [0.25, 0.18181818181818182, 0.2105263157894737]
metrics_current: [0.14735099337748345, 0.12552891396332863, 0.13556740289413557]
text: This paper solves a specialized regression problem to obtain sampling probabilities for records in databases .
result: triple_list: [["regression problem", "Used_for", "sampling probabilities"]]
pred: [('regression problem', 'Used_for', 'sampling probabilities')]
trues: [['specialized regression problem', 'Used_for', 'sampling probabilities'], ['sampling probabilities', 'Used_for', 'records'], ['records', 'Part_of', 'databases']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14710743801652892, 0.125, 0.13515565679574792]
text: Experiments using the SemCor and Senseval-3 data sets demonstrate that our ensembles yield significantly better results when compared with state-of-the-art .
result: triple_list: [["SemCor", "Used_for", "ensembles"], ["Senseval-3 data sets", "Compare", "ensembles"], ["state-of-the-art", "Compare", "ensembles"]]
pred: [('SemCor', 'Used_for', 'ensembles'), ('Senseval-3 data sets', 'Compare', 'ensembles'), ('state-of-the-art', 'Compare', 'ensembles')]
trues: [['SemCor and Senseval-3 data sets', 'Evaluate_for', 'ensembles'], ['SemCor and Senseval-3 data sets', 'Evaluate_for', 'state-of-the-art']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14638157894736842, 0.12464985994397759, 0.1346444780635401]
text: Building on previous work at Carnegie-Mellon University e.g. [ 4 , 5 , 8 ] , Plume 's approach to parsing is based on semantic caseframe instantiation .
result: triple_list: [["Carnegie-Mellon University", "Conjunction", "Plume 's approach to parsing"], ["semantic caseframe instantiation", "Used_for", "Plume 's approach to parsing"]]
pred: [('Carnegie-Mellon University', 'Conjunction', "Plume 's approach to parsing"), ('semantic caseframe instantiation', 'Used_for', "Plume 's approach to parsing")]
trues: [["Plume 's approach", 'Used_for', 'parsing'], ['semantic caseframe instantiation', 'Used_for', "Plume 's approach"]]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14590163934426228, 0.12430167597765363, 0.13423831070889894]
text: We also address a more general problem of matrix rank degeneration & non-isolated minima in the low-rank matrix optimization by using new type of regularizer which approximately enforces the or-thonormality of the learned matrix very efficiently .
result: triple_list: [["matrix rank degeneration & non-isolated minima", "Conjunction", "low-rank matrix optimization"], ["low-rank matrix optimization", "Used_for", "matrix rank degeneration & non-isolated minima"], ["regularizer", "Used_for", "low-rank matrix optimization"], ["regularizer", "Part_of", "low-rank matrix optimization"], ["matrix rank degeneration & non-isolated minima", "Part_of", "low-rank matrix optimization"], ["or-thonormality", "Used_for", "matrix rank degeneration & non-isolated minima"]]
pred: [('matrix rank degeneration & non-isolated minima', 'Conjunction', 'low-rank matrix optimization'), ('low-rank matrix optimization', 'Used_for', 'matrix rank degeneration & non-isolated minima'), ('regularizer', 'Used_for', 'low-rank matrix optimization'), ('regularizer', 'Part_of', 'low-rank matrix optimization'), ('matrix rank degeneration & non-isolated minima', 'Part_of', 'low-rank matrix optimization'), ('or-thonormality', 'Used_for', 'matrix rank degeneration & non-isolated minima')]
trues: [['matrix rank degeneration', 'Conjunction', 'non-isolated minima'], ['matrix rank degeneration', 'Feature_of', 'low-rank matrix optimization'], ['non-isolated minima', 'Feature_of', 'low-rank matrix optimization'], ['regularizer', 'Used_for', 'low-rank matrix optimization'], ['regularizer', 'Used_for', 'or-thonormality'], ['or-thonormality', 'Feature_of', 'learned matrix']]
metrics_sample: [0.16666666666666666, 0.16666666666666666, 0.16666666666666666]
metrics_current: [0.1461038961038961, 0.12465373961218837, 0.13452914798206278]
text: Our extensive experimental results significantly improve over both uniform sampling and standard stratified sampling which are de-facto the industry standards .
result: triple_list: [["uniform sampling", "Compare", "stratified sampling"], ["industry standards", "Compare", "stratified sampling"]]
pred: [('uniform sampling', 'Compare', 'stratified sampling'), ('industry standards', 'Compare', 'stratified sampling')]
trues: [['uniform sampling', 'Conjunction', 'stratified sampling']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14563106796116504, 0.12448132780082988, 0.13422818791946306]
text: This paper presents a machine learning approach to bare slice disambiguation in dialogue .
result: triple_list: [["machine learning approach", "Used_for", "bare slice disambiguation in dialogue"]]
pred: [('machine learning approach', 'Used_for', 'bare slice disambiguation in dialogue')]
trues: [['machine learning approach', 'Used_for', 'bare slice disambiguation'], ['dialogue', 'Used_for', 'bare slice disambiguation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14539579967689822, 0.12413793103448276, 0.13392857142857142]
text: This paper highlights a particular class of miscommunication -- reference problems -- by describing a case study and techniques for avoiding failures of reference .
result: triple_list: [["miscommunication", "Part_of", "class of miscommunication"], ["reference problems", "Used_for", "case study"], ["techniques", "Used_for", "avoiding failures of reference"]]
pred: [('miscommunication', 'Part_of', 'class of miscommunication'), ('reference problems', 'Used_for', 'case study'), ('techniques', 'Used_for', 'avoiding failures of reference')]
trues: [['reference problems', 'Hyponym_of', 'miscommunication'], ['techniques', 'Used_for', 'failures of reference']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14469453376205788, 0.12379642365887207, 0.1334321719792439]
text: We have previously introduced a statistical model describing the generating process of speech F0 contours , based on the discrete-time version of the Fujisaki model .
result: triple_list: [["statistical model", "Used_for", "generating process speech F0 contours"]]
pred: [('statistical model', 'Used_for', 'generating process speech F0 contours')]
trues: [['statistical model', 'Used_for', 'speech F0 contours'], ['Fujisaki model', 'Used_for', 'statistical model']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14446227929373998, 0.12345679012345678, 0.1331360946745562]
text: In comparison with previous works , in this paper it is assumed that the signals are not i.i.d. in each epoch , but obey a first-order autoregressive model .
result: triple_list: [["it", "Feature_of", "first-order autoregressive model"]]
pred: [('it', 'Feature_of', 'first-order autoregressive model')]
trues: [['first-order autoregressive model', 'Used_for', 'signals']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14423076923076922, 0.1232876712328767, 0.1329394387001477]
text: We analyzed eye gaze , head nods and attentional focus in the context of a direction-giving task .
result: The candidate relations for this text are:
Conjunction
Conjunction
Used_for
The candidate entities for this text are:
eye gaze
head nods
eye gaze
attentional focus
direction-giving task
attentional focus

triple_list: [["eye gaze", "Conjunction", "head nods"], ["eye gaze", "Conjunction", "attentional focus"], ["direction-giving task", "Used_for", "attentional focus"]]
pred: [('eye gaze', 'Conjunction', 'head nods'), ('eye gaze', 'Conjunction', 'attentional focus'), ('direction-giving task', 'Used_for', 'attentional focus')]
trues: [['eye gaze', 'Conjunction', 'head nods'], ['eye gaze', 'Part_of', 'direction-giving task'], ['head nods', 'Conjunction', 'attentional focus'], ['head nods', 'Part_of', 'direction-giving task'], ['attentional focus', 'Part_of', 'direction-giving task']]
metrics_sample: [0.3333333333333333, 0.2, 0.25]
metrics_current: [0.14513556618819776, 0.12380952380952381, 0.13362701908957414]
text: We report the performance of the MBR decoders on a Chinese-to-English translation task .
result: triple_list: [["Chinese-to-English translation task", "Feature_of", "MBR decoders"]]
pred: [('Chinese-to-English translation task', 'Feature_of', 'MBR decoders')]
trues: [['MBR decoders', 'Used_for', 'Chinese-to-English translation task']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1449044585987261, 0.12364130434782608, 0.13343108504398826]
text: Although the study of clustering is centered around an intuitively compelling goal , it has been very difficult to develop a unified framework for reasoning about it at a technical level , and profoundly diverse approaches to clustering abound in the research community .
result: triple_list: [["it", "Feature_of", "framework"]]
pred: [('it', 'Feature_of', 'framework')]
trues: [['unified framework', 'Used_for', 'reasoning']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14467408585055644, 0.12347354138398914, 0.13323572474377746]
text: The key idea of our approach is to use different view points for reasoning about contradictions and consistencies between multiple depth maps generated with the same stereo algorithm .
result: triple_list: [["view points", "Used_for", "reasoning"]]
pred: [('view points', 'Used_for', 'reasoning')]
trues: [['view points', 'Used_for', 'approach']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14444444444444443, 0.12330623306233063, 0.13304093567251463]
text: MINPRAN 's properties are connrmed experimentally on synthetic data and compare favorably to least median of squares .
result: triple_list: [["synthetic data", "Evaluate_for", "MINPRAN 's"], ["synthetic data", "Compare", "least median of squares"]]
pred: [('synthetic data', 'Evaluate_for', "MINPRAN 's"), ('synthetic data', 'Compare', 'least median of squares')]
trues: [['synthetic data', 'Evaluate_for', 'MINPRAN'], ['least median of squares', 'Compare', 'MINPRAN']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1439873417721519, 0.12297297297297298, 0.13265306122448978]
text: It has also been studied in the framework of Japanese information extraction ( [ 3 ] ) in recent years .
result: The candidate relations for this text are:
Evaluate_for
The candidate entities for this text are:
Japanese information extraction
It

triple_list: [["Japanese information extraction", "Evaluate_for", "It"]]
pred: [('Japanese information extraction', 'Evaluate_for', 'It')]
trues: [['Japanese information extraction', 'Used_for', 'It']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14375987361769352, 0.12280701754385964, 0.13245997088791847]
text: Metagrammatical formalisms that combine context-free phrase structure rules and metarules ( MPS grammars ) allow concise statement of generalizations about the syntax of natural languages .
result: triple_list: [["context-free phrase structure rules", "Conjunction", "metarules ( MPS grammars )"], ["generalizations", "Conjunction", "syntax of natural languages"]]
pred: [('context-free phrase structure rules', 'Conjunction', 'metarules ( MPS grammars )'), ('generalizations', 'Conjunction', 'syntax of natural languages')]
trues: [['context-free phrase structure rules', 'Part_of', 'Metagrammatical formalisms'], ['context-free phrase structure rules', 'Conjunction', 'metarules ( MPS grammars )'], ['metarules ( MPS grammars )', 'Part_of', 'Metagrammatical formalisms']]
metrics_sample: [0.5, 0.3333333333333333, 0.4]
metrics_current: [0.14488188976377953, 0.12365591397849462, 0.13343002175489485]
text: This paper considers the problem of reconstructing the motion of a 3D articulated tree from 2D point correspondences subject to some temporal prior .
result: triple_list: [["2D point correspondences", "Used_for", "motion of 3D articulated tree"]]
pred: [('2D point correspondences', 'Used_for', 'motion of 3D articulated tree')]
trues: [['2D point correspondences', 'Used_for', 'reconstructing the motion of a 3D articulated tree']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14465408805031446, 0.12348993288590604, 0.13323678493845043]
text: This research is part of a larger study of anaphoric expressions , the results of which will be incorporated into a natural language generation system .
result: triple_list: [["anaphoric expressions", "Part_of", "study"]]
pred: [('anaphoric expressions', 'Part_of', 'study')]
trues: [['anaphoric expressions', 'Used_for', 'natural language generation system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14442700156985872, 0.12332439678284182, 0.13304410701373823]
text: Online action detection goes one step further and is more challenging , which identifies the action type and localizes the action positions on the fly from the untrimmed stream .
result: triple_list: [["action type", "Feature_of", "action positions"], ["action positions", "Part_of", "the untrimmed stream"]]

pred: [('action type', 'Feature_of', 'action positions'), ('action positions', 'Part_of', 'the untrimmed stream')]
trues: [['Online action detection', 'Used_for', 'action type'], ['Online action detection', 'Used_for', 'action positions'], ['action type', 'Conjunction', 'action positions'], ['untrimmed stream', 'Used_for', 'Online action detection']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14397496087636932, 0.12266666666666666, 0.13246940244780417]
text: While sentence extraction as an approach to summarization has been shown to work in documents of certain genres , because of the conversational nature of email communication where utterances are made in relation to one made previously , sentence extraction may not capture the necessary segments of dialogue that would make a summary coherent .
result: triple_list: [["sentence extraction", "Used_for", "summarization"]]
pred: [('sentence extraction', 'Used_for', 'summarization')]
trues: [['sentence extraction', 'Used_for', 'summarization']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.1453125, 0.12383488681757657, 0.13371675053918045]
text: We compare our results to state of the art methods such as mi-cro phase shifting and modulated phase shifting .
result: The candidate relations for this text are:
Compare
The candidate entities for this text are:
mi-cro phase shifting and modulated phase shifting
methods

triple_list: [["mi-cro phase shifting and modulated phase shifting", "Compare", "methods"]]
pred: [('mi-cro phase shifting and modulated phase shifting', 'Compare', 'methods')]
trues: [['mi-cro phase shifting', 'Hyponym_of', 'state of the art methods'], ['mi-cro phase shifting', 'Conjunction', 'modulated phase shifting'], ['modulated phase shifting', 'Hyponym_of', 'state of the art methods']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14508580343213728, 0.123342175066313, 0.13333333333333333]
text: Experiments on the TREC Blog track test set show that both groups of credibility indicators significantly improve retrieval effectiveness ; the best performance is achieved when combining them .
result: triple_list: [["TREC Blog track test set", "Used_for", "retrieval effectiveness"], ["groups of credibility indicators", "Compare", "them"]]
pred: [('TREC Blog track test set', 'Used_for', 'retrieval effectiveness'), ('groups of credibility indicators', 'Compare', 'them')]
trues: [['TREC Blog track test set', 'Evaluate_for', 'credibility indicators'], ['retrieval effectiveness', 'Evaluate_for', 'credibility indicators']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14463452566096424, 0.12301587301587301, 0.13295210864903503]
text: The goal of this work is the enrichment of human-machine interactions in a natural language environment .
result: triple_list: [["natural language environment", "Feature_of", "human-machine interactions"]]
pred: [('natural language environment', 'Feature_of', 'human-machine interactions')]
trues: [['natural language environment', 'Feature_of', 'human-machine interactions']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.14596273291925466, 0.12417437252311757, 0.13418986438258387]
text: To recover from these inevitable tracking failures , we consider object detection as a global optimization problem and solve it via Adaptive Simulated Annealing ( ASA ) , a method that avoids becoming trapped at local modes and is much faster than exhaustive search .
result: triple_list: [["object detection", "Used_for", "global optimization problem"], ["Adaptive Simulated Annealing ( ASA )", "Conjunction", "method"], ["exhaustive search", "Conjunction", "Adaptive Simulated Annealing ( ASA )"]]
pred: [('object detection', 'Used_for', 'global optimization problem'), ('Adaptive Simulated Annealing ( ASA )', 'Conjunction', 'method'), ('exhaustive search', 'Conjunction', 'Adaptive Simulated Annealing ( ASA )')]
trues: [['global optimization problem', 'Used_for', 'object detection'], ['Adaptive Simulated Annealing ( ASA )', 'Used_for', 'it'], ['method', 'Compare', 'exhaustive search']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14528593508500773, 0.12368421052631579, 0.1336176261549396]
text: b ) The UV procedure is based on three different confidence tests , two based on acoustic measures and one founded on linguistic information , applied in a hierarchical structure .
result: triple_list: [["UV procedure", "Used_for", "confidence tests"], ["acoustic measures", "Hyponym_of", "confidence tests"], ["linguistic information", "Hyponym_of", "confidence tests"], ["acoustic measures", "Used_for", "UV procedure"], ["linguistic information", "Used_for", "UV procedure"], ["hierarchical structure", "Used_for", "UV procedure"]]
pred: [('UV procedure', 'Used_for', 'confidence tests'), ('acoustic measures', 'Hyponym_of', 'confidence tests'), ('linguistic information', 'Hyponym_of', 'confidence tests'), ('acoustic measures', 'Used_for', 'UV procedure'), ('linguistic information', 'Used_for', 'UV procedure'), ('hierarchical structure', 'Used_for', 'UV procedure')]
trues: [['confidence tests', 'Used_for', 'UV procedure'], ['confidence tests', 'Used_for', 'hierarchical structure'], ['two', 'Hyponym_of', 'confidence tests'], ['acoustic measures', 'Used_for', 'two'], ['one', 'Hyponym_of', 'confidence tests'], ['linguistic information', 'Used_for', 'one']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1439509954058193, 0.1227154046997389, 0.1324876673713883]
text: These mattes are implied by a set of hypothesized object boundary fragments in the scene .
result: triple_list: [["matts", "Part_of", "hypothesized object boundary fragments in the scene"]]
pred: [('matts', 'Part_of', 'hypothesized object boundary fragments in the scene')]
trues: [['hypothesized object boundary fragments', 'Used_for', 'mattes']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1437308868501529, 0.12255541069100391, 0.13230119634060522]
text: It works by calculating eigenvectors of an adjacency graph 's Laplacian to recover a submanifold of data from a high dimensionality space and then performing cluster number estimation on the eigenvectors .
result: triple_list: [["eigenvectors", "Used_for", "cluster number estimation"], ["Laplacian", "Used_for", "eigenvectors"], ["high dimensionality space", "Hyponym_of", "eigenvectors"]]
pred: [('eigenvectors', 'Used_for', 'cluster number estimation'), ('Laplacian', 'Used_for', 'eigenvectors'), ('high dimensionality space', 'Hyponym_of', 'eigenvectors')]
trues: [['It', 'Used_for', 'submanifold'], ['eigenvectors', 'Used_for', 'It'], ["adjacency graph 's Laplacian", 'Feature_of', 'eigenvectors'], ['high dimensionality space', 'Used_for', 'submanifold'], ['cluster number estimation', 'Used_for', 'It'], ['cluster number estimation', 'Used_for', 'eigenvectors']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1430745814307458, 0.12160413971539456, 0.13146853146853144]
text: This motor control representation enables successful word spotting and matching of cursive scripts .
result: triple_list: [["motor control representation", "Used_for", "word spotting"], ["cursive scripts", "Used_for", "motor control representation"]]
pred: [('motor control representation', 'Used_for', 'word spotting'), ('cursive scripts', 'Used_for', 'motor control representation')]
trues: [['motor control representation', 'Used_for', 'word spotting'], ['motor control representation', 'Used_for', 'matching of cursive scripts'], ['word spotting', 'Conjunction', 'matching of cursive scripts']]
metrics_sample: [0.5, 0.3333333333333333, 0.4]
metrics_current: [0.1441578148710167, 0.12242268041237113, 0.13240418118466898]
text: In this paper , we describe a search procedure for statistical machine translation ( MT ) based on dynamic programming ( DP ) .
result: triple_list: [["search procedure", "Used_for", "statistical machine translation ( MT )"]]
pred: [('search procedure', 'Used_for', 'statistical machine translation ( MT )')]
trues: [['search procedure', 'Used_for', 'statistical machine translation ( MT )'], ['dynamic programming ( DP )', 'Used_for', 'statistical machine translation ( MT )']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.14545454545454545, 0.12339331619537275, 0.13351877607788595]
text: Unfortunately , creating large datasets with pixel-level labels has been extremely costly due to the amount of human effort required .
result: triple_list: [["human effort", "Evaluate_for", "dataset"], ["human effort", "Compare", "computational effort"]]
pred: [('human effort', 'Evaluate_for', 'dataset'), ('human effort', 'Compare', 'computational effort')]
trues: [['pixel-level labels', 'Feature_of', 'large datasets']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14501510574018128, 0.12323491655969192, 0.13324080499653018]
text: Unlike existing interest point detectors , which measure pixel-wise differences in image intensity , our detectors incorporate histogram-based representations , and thus can find image regions that present a distinct distribution in the neighborhood .
result: triple_list: [["interest point detectors", "Compare", "detectors"], ["histogram-based representations", "Used_for", "detectors"], ["image regions", "Used_for", "distinct distribution in the neighborhood"]]
pred: [('interest point detectors', 'Compare', 'detectors'), ('histogram-based representations', 'Used_for', 'detectors'), ('image regions', 'Used_for', 'distinct distribution in the neighborhood')]
trues: [['pixel-wise differences in image intensity', 'Evaluate_for', 'interest point detectors'], ['histogram-based representations', 'Part_of', 'detectors']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1443609022556391, 0.12291933418693982, 0.13278008298755187]
text: Towards this goal , we also propose a novel Multiple Instance Learning ( MIL ) formulation for the problem based on the logistic softmax function of covariance-based region features within a MAP estimation framework .
result: triple_list: [["Multiple Instance Learning ( MIL ) formulation", "Used_for", "problem"], ["logistic softmax function of covariance-based region features", "Used_for", "MAP estimation framework"], ["Multiple Instance Learning ( MIL ) formulation", "Used_for", "problem"]]
pred: [('Multiple Instance Learning ( MIL ) formulation', 'Used_for', 'problem'), ('logistic softmax function of covariance-based region features', 'Used_for', 'MAP estimation framework'), ('Multiple Instance Learning ( MIL ) formulation', 'Used_for', 'problem')]
trues: [['logistic softmax function of covariance-based region features', 'Used_for', 'Multiple Instance Learning ( MIL ) formulation'], ['MAP estimation framework', 'Used_for', 'Multiple Instance Learning ( MIL ) formulation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14392803598200898, 0.12260536398467432, 0.13241379310344825]
text: We believe that these evaluation techniques will provide information about both the human language learning process , the translation process and the development of machine translation systems .
result: triple_list: [["human language learning process", "Conjunction", "translation process"], ["translation process", "Conjunction", "development of machine translation systems"]]
pred: [('human language learning process', 'Conjunction', 'translation process'), ('translation process', 'Conjunction', 'development of machine translation systems')]
trues: [['evaluation techniques', 'Used_for', 'human language learning process'], ['evaluation techniques', 'Used_for', 'translation process'], ['evaluation techniques', 'Used_for', 'machine translation systems'], ['human language learning process', 'Conjunction', 'translation process'], ['translation process', 'Conjunction', 'machine translation systems']]
metrics_sample: [0.5, 0.2, 0.28571428571428575]
metrics_current: [0.14499252615844543, 0.12309644670050761, 0.13315030885380919]
text: The applicability of many current information extraction techniques is severely limited by the need for supervised training data .
result: triple_list: [["supervised training data", "Hyponym_of", "applicability of information extraction techniques"]]
pred: [('supervised training data', 'Hyponym_of', 'applicability of information extraction techniques')]
trues: [['supervised training data', 'Used_for', 'information extraction techniques']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14477611940298507, 0.1229404309252218, 0.13296778615490062]
text: The new criterion -- meaning-entailing substitutability -- fits the needs of semantic-oriented NLP applications and can be evaluated directly ( independent of an application ) at a good level of human agreement .
result: triple_list: [["meaning-entailing substitutability", "Evaluate_for", "semantic-oriented NLP applications"], ["criterion", "Evaluate_for", "human"]]
pred: [('meaning-entailing substitutability', 'Evaluate_for', 'semantic-oriented NLP applications'), ('criterion', 'Evaluate_for', 'human')]
trues: [['meaning-entailing substitutability', 'Used_for', 'semantic-oriented NLP applications'], ['human agreement', 'Evaluate_for', 'meaning-entailing substitutability']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14434523809523808, 0.12262958280657396, 0.13260423786739575]
text: A separation method is proposed that is nearly statistically efficient ( approaching the corresponding Cramr-Rao lower bound ) , if the separated signals obey the assumed model .
result: triple_list: [["separation method", "Evaluate_for", "statistically efficient ( approaching the corresponding Cramr-Rao lower bound )"]]
pred: [('separation method', 'Evaluate_for', 'statistically efficient ( approaching the corresponding Cramr-Rao lower bound )')]
trues: [['Cramr-Rao lower bound )', 'Feature_of', 'separation method']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14413075780089152, 0.12247474747474747, 0.13242320819112627]
text: Turkish is an agglutinative language with word structures formed by productive affixations of derivational and inflectional suffixes to root words .
result: triple_list: [["Turkish", "Conjunction", "agglutinative language"], ["word structures", "Feature_of", "Turkish"], ["productive affixations", "Feature_of", "word structures"], ["derivational and inflectional suffixes", "Conjunction", "root words"]]
pred: [('Turkish', 'Conjunction', 'agglutinative language'), ('word structures', 'Feature_of', 'Turkish'), ('productive affixations', 'Feature_of', 'word structures'), ('derivational and inflectional suffixes', 'Conjunction', 'root words')]
trues: [['Turkish', 'Hyponym_of', 'agglutinative language'], ['word structures', 'Feature_of', 'agglutinative language'], ['productive affixations of derivational and inflectional suffixes', 'Part_of', 'word structures']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1432791728212703, 0.1220125786163522, 0.13179347826086957]
text: We test our algorithm on the detection task and the viewpoint classification task by using '' car '' category from both the Savarese et al. 2007 and PASCAL VOC 2006 datasets .
result: triple_list: [["detection task", "Used_for", "algorithm"], ["viewpoint classification task", "Used_for", "algorithm"], [["car", "Hyponym_of"], ["car", "Used_for", "viewpoint classification task"]], ["Savarese et al. 2007 and PASCAL VOC 2006 datasets", "Evaluate_for", "detection task"]]
pred: [('detection task', 'Used_for', 'algorithm'), ('viewpoint classification task', 'Used_for', 'algorithm'), ('car', 'Used_for', 'viewpoint classification task'), ('Savarese et al. 2007 and PASCAL VOC 2006 datasets', 'Evaluate_for', 'detection task')]
trues: [['algorithm', 'Used_for', 'detection task'], ['algorithm', 'Used_for', 'viewpoint classification task'], ['detection task', 'Conjunction', 'viewpoint classification task'], ['PASCAL VOC 2006 datasets', 'Evaluate_for', 'algorithm']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14243759177679882, 0.1214017521902378, 0.13108108108108107]
text: We show that there is a closed-form ( analytical ) solution for one part of the Kullback-Leibler distance , viz the cross-entropy .
result: triple_list: [["Kullback-Leibler distance", "Part_of", "cross-entropy"]]
pred: [('Kullback-Leibler distance', 'Part_of', 'cross-entropy')]
trues: [['closed-form ( analytical ) solution', 'Used_for', 'Kullback-Leibler distance'], ['closed-form ( analytical ) solution', 'Used_for', 'cross-entropy'], ['cross-entropy', 'Part_of', 'Kullback-Leibler distance']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14222873900293256, 0.12094763092269327, 0.1307277628032345]
text: Inherent ambiguities in the computation of features are addressed by using a data-dependent bandwidth for density estimation using kernels .
result: triple_list: [["data-dependent bandwidth", "Used_for", "features"]]
pred: [('data-dependent bandwidth', 'Used_for', 'features')]
trues: [['ambiguities', 'Feature_of', 'computation of features'], ['data-dependent bandwidth', 'Used_for', 'ambiguities'], ['data-dependent bandwidth', 'Used_for', 'density estimation'], ['kernels', 'Used_for', 'density estimation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14202049780380674, 0.12034739454094293, 0.1302887844190732]
text: We introduce a novel method of shape constrained image segmentation which is based on mixtures of feature distributions for color and texture as well as probabilistic shape knowledge .
result: triple_list: [["method", "Used_for", "shape constrained image segmentation"]]
pred: [('method', 'Used_for', 'shape constrained image segmentation')]
trues: [['method', 'Used_for', 'shape constrained image segmentation'], ['mixtures of feature distributions', 'Used_for', 'method'], ['mixtures of feature distributions', 'Used_for', 'color'], ['mixtures of feature distributions', 'Used_for', 'texture'], ['mixtures of feature distributions', 'Used_for', 'probabilistic shape knowledge'], ['color', 'Conjunction', 'texture'], ['texture', 'Conjunction', 'probabilistic shape knowledge']]
metrics_sample: [1.0, 0.14285714285714285, 0.25]
metrics_current: [0.14327485380116958, 0.12054120541205413, 0.13092852371409486]
text: The system incorporates a decision-tree classifier for 30 scf types which tests for the presence of grammatical relations ( grs ) in the output of a robust statistical parser .
result: triple_list: [["decision-tree classifier", "Part_of", "system"], ["scf types", "Hyponym_of", "decision-tree classifier"], ["grammatical relations ( grs )", "Conjunction", "statistical parser"], ["statistical parser", "Used_for", "grammatical relations ( grs )"]]
pred: [('decision-tree classifier', 'Part_of', 'system'), ('scf types', 'Hyponym_of', 'decision-tree classifier'), ('grammatical relations ( grs )', 'Conjunction', 'statistical parser'), ('statistical parser', 'Used_for', 'grammatical relations ( grs )')]
trues: [['decision-tree classifier', 'Part_of', 'system'], ['decision-tree classifier', 'Used_for', 'grammatical relations ( grs )']]
metrics_sample: [0.25, 0.5, 0.3333333333333333]
metrics_current: [0.1438953488372093, 0.12147239263803682, 0.1317365269461078]
text: This paper describes FERRET , an interactive question-answering ( Q/A ) system designed to address the challenges of integrating automatic Q/A applications into real-world environments .
result: triple_list: [["FERRET", "Used_for", "interactive question-answering ( Q/A ) system"], ["interactive question-answering ( Q/A ) system", "Used_for", "real-world environments"]]
pred: [('FERRET', 'Used_for', 'interactive question-answering ( Q/A ) system'), ('interactive question-answering ( Q/A ) system', 'Used_for', 'real-world environments')]
trues: [['FERRET', 'Hyponym_of', 'interactive question-answering ( Q/A ) system'], ['FERRET', 'Used_for', 'integrating automatic Q/A applications into real-world environments']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14347826086956522, 0.1211750305997552, 0.13138686131386862]
text: We integrate a spoken language understanding system with intelligent mobile agents that mediate between users and information sources .
result: The candidate relations for this text are:
Used_for
Part_of
The candidate entities for this text are:
spoken language understanding system
intelligent mobile agents
intelligent mobile agents
mediation

triple_list: [["spoken language understanding system", "Used_for", "intelligent mobile agents"], ["intelligent mobile agents", "Part_of", "mediation"]]
pred: [('spoken language understanding system', 'Used_for', 'intelligent mobile agents'), ('intelligent mobile agents', 'Part_of', 'mediation')]
trues: [['intelligent mobile agents', 'Part_of', 'spoken language understanding system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1430635838150289, 0.12102689486552567, 0.13112582781456952]
text: Amorph recognizes NE items in two stages : dictionary lookup and rule application .
result: triple_list: [["NE items", "Feature_of", "Amorph"], ["dictionary lookup", "Hyponym_of", "rule application"]]
pred: [('NE items', 'Feature_of', 'Amorph'), ('dictionary lookup', 'Hyponym_of', 'rule application')]
trues: [['Amorph', 'Used_for', 'NE items'], ['dictionary lookup', 'Part_of', 'Amorph'], ['dictionary lookup', 'Conjunction', 'rule application'], ['rule application', 'Part_of', 'Amorph']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14265129682997119, 0.12043795620437957, 0.13060686015831133]
text: In this paper , we propose a novel moderate positive sample mining method to train robust CNN for person re-identification , dealing with the problem of large variation .
result: triple_list: [["moderate positive sample mining method", "Used_for", "robust CNN for person re-identification"]]
pred: [('moderate positive sample mining method', 'Used_for', 'robust CNN for person re-identification')]
trues: [['moderate positive sample mining method', 'Used_for', 'robust CNN'], ['robust CNN', 'Used_for', 'person re-identification']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14244604316546763, 0.12014563106796117, 0.13034891375905203]
text: We examine the relationship between the two grammatical formalisms : Tree Adjoining Grammars and Head Grammars .
result: triple_list: [["grammatical formalisms", "Conjunction", "Tree Adjoining Grammars and Head Grammars"]]
pred: [('grammatical formalisms', 'Conjunction', 'Tree Adjoining Grammars and Head Grammars')]
trues: [['Tree Adjoining Grammars', 'Hyponym_of', 'grammatical formalisms'], ['Tree Adjoining Grammars', 'Compare', 'Head Grammars'], ['Head Grammars', 'Hyponym_of', 'grammatical formalisms']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14224137931034483, 0.11970979443772672, 0.13000656598818122]
text: We apply cluster analysis on the sampled parameter space to redetect the object and renew the local tracker .
result: triple_list: [["sampled parameter space", "Used_for", "cluster analysis"], ["object", "Hyponym_of", "trackers"], ["local tracker", "Hyponym_of", "trackers"]]
pred: [('sampled parameter space', 'Used_for', 'cluster analysis'), ('object', 'Hyponym_of', 'trackers'), ('local tracker', 'Hyponym_of', 'trackers')]
trues: [['cluster analysis', 'Used_for', 'sampled parameter space'], ['cluster analysis', 'Used_for', 'local tracker']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14163090128755365, 0.11942098914354644, 0.12958115183246072]
text: Among other experiments , we demonstrate the potential of our approach by boosting the performance of three learned confidence measures on the KITTI2012 dataset by simply training them on a vast amount of automatically generated training data rather than a limited amount of laser ground truth data .
result: triple_list: [["approach", "Used_for", "learned confidence measures"], ["approach", "Used_for", "KITTI2012 dataset"], ["training data", "Compare", "laser ground truth data"]]
pred: [('approach', 'Used_for', 'learned confidence measures'), ('approach', 'Used_for', 'KITTI2012 dataset'), ('training data', 'Compare', 'laser ground truth data')]
trues: [['approach', 'Used_for', 'learned confidence measures'], ['KITTI2012 dataset', 'Evaluate_for', 'learned confidence measures'], ['automatically generated training data', 'Used_for', 'them'], ['laser ground truth data', 'Compare', 'automatically generated training data']]
metrics_sample: [0.3333333333333333, 0.25, 0.28571428571428575]
metrics_current: [0.14245014245014245, 0.12004801920768307, 0.13029315960912052]
text: We introduce a method to accelerate the evaluation of object detection cascades with the help of a divide-and-conquer procedure in the space of candidate regions .
result: triple_list: [["method", "Used_for", "object detection cascades"], ["divide-and-conquer procedure", "Used_for", "space of candidate regions"]]
pred: [('method', 'Used_for', 'object detection cascades'), ('divide-and-conquer procedure', 'Used_for', 'space of candidate regions')]
trues: [['method', 'Used_for', 'evaluation of object detection cascades'], ['divide-and-conquer procedure', 'Used_for', 'method'], ['space of candidate regions', 'Feature_of', 'divide-and-conquer procedure']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14204545454545456, 0.11961722488038277, 0.12987012987012989]
text: We then use the predicates of such clauses to create a set of domain independent features to annotate an input dataset , and run two different machine learning algorithms : SLIPPER , a rule-based learning algorithm , and TiMBL , a memory-based system .
result: triple_list: [["SLIPPER", "Used_for", "machine learning algorithms"], ["TiMBL", "Used_for", "memory-based system"]]
pred: [('SLIPPER', 'Used_for', 'machine learning algorithms'), ('TiMBL', 'Used_for', 'memory-based system')]
trues: [['SLIPPER', 'Hyponym_of', 'rule-based learning algorithm'], ['rule-based learning algorithm', 'Part_of', 'machine learning algorithms'], ['rule-based learning algorithm', 'Compare', 'memory-based system'], ['TiMBL', 'Hyponym_of', 'memory-based system'], ['memory-based system', 'Part_of', 'machine learning algorithms']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.141643059490085, 0.11890606420927467, 0.12928248222365868]
text: SVMs are known to be robust to overfitting ; however , a few training examples usually do not represent well the structure of the class .
result: triple_list: [["overfitting ;", "Used_for", "SVMs"]]
pred: [('overfitting ;', 'Used_for', 'SVMs')]
trues: [['SVMs', 'Used_for', 'overfitting']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14144271570014144, 0.1187648456057007, 0.12911555842479017]
text: A method for producing such phrases from a word-aligned corpora is proposed .
result: triple_list: [["phrases", "Used_for", "word-aligned corpora"]]
pred: [('phrases', 'Used_for', 'word-aligned corpora')]
trues: [['method', 'Used_for', 'phrases'], ['word-aligned corpora', 'Evaluate_for', 'method']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14124293785310735, 0.11848341232227488, 0.12886597938144329]
text: In the Object Recognition task , there exists a di-chotomy between the categorization of objects and estimating object pose , where the former necessitates a view-invariant representation , while the latter requires a representation capable of capturing pose information over different categories of objects .
result: triple_list: [["categorization of objects", "Used_for", "Object Recognition task"]]
pred: [('categorization of objects', 'Used_for', 'Object Recognition task')]
trues: [['categorization of objects', 'Part_of', 'Object Recognition task'], ['categorization of objects', 'Conjunction', 'estimating object pose'], ['estimating object pose', 'Part_of', 'Object Recognition task'], ['view-invariant representation', 'Used_for', 'former'], ['representation', 'Used_for', 'latter'], ['representation', 'Used_for', 'pose information']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14104372355430184, 0.11764705882352941, 0.12828736369467605]
text: We investigate several voting - and arbiter-based combination strategies over a diverse pool of unsupervised WSD systems .
result: The candidate relations for this text are:
Used_for
Used_for
Used_for
Conjunction
The candidate entities for this text are:
voting - and arbiter-based combination strategies
unsupervised WSD systems
unsupervised WSD systems
unsupervised WSD systems
WSD
unsupervised WSD systems
unsupervised WSD systems
WSD

triple_list: [["voting - and arbiter-based combination strategies", "Used_for", "unsupervised WSD systems"], ["unsupervised WSD systems", "Used_for", "unsupervised WSD systems"], ["WSD", "Used_for", "unsupervised WSD systems"], ["unsupervised WSD systems", "Conjunction", "WSD"]]
pred: [('voting - and arbiter-based combination strategies', 'Used_for', 'unsupervised WSD systems'), ('unsupervised WSD systems', 'Used_for', 'unsupervised WSD systems'), ('WSD', 'Used_for', 'unsupervised WSD systems'), ('unsupervised WSD systems', 'Conjunction', 'WSD')]
trues: [['voting - and arbiter-based combination strategies', 'Used_for', 'unsupervised WSD systems']]
metrics_sample: [0.25, 1.0, 0.4]
metrics_current: [0.14165497896213183, 0.11868390129259694, 0.12915601023017903]
text: We use gray-level band-pass white noise patterns that increase robustness to indirect lighting and scene discontinuities .
result: triple_list: [["gray-level band-pass white noise patterns", "Used_for", "robustness"]]
pred: [('gray-level band-pass white noise patterns', 'Used_for', 'robustness')]
trues: [['robustness', 'Evaluate_for', 'gray-level band-pass white noise patterns'], ['indirect lighting', 'Feature_of', 'robustness'], ['indirect lighting', 'Conjunction', 'scene discontinuities'], ['scene discontinuities', 'Feature_of', 'robustness']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14145658263305322, 0.11812865497076024, 0.12874442319949012]
text: We discuss several applications of the result to the problem of distributional approximation of probabilistic context-free grammars by means of probabilistic finite automata .
result: triple_list: [["distributional approximation of probabilistic context-free grammars", "Used_for", "probabilistic finite automata"]]
pred: [('distributional approximation of probabilistic context-free grammars', 'Used_for', 'probabilistic finite automata')]
trues: [['distributional approximation', 'Feature_of', 'probabilistic context-free grammars'], ['probabilistic finite automata', 'Used_for', 'distributional approximation']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14125874125874127, 0.11785297549591599, 0.12849872773536894]
text: In this paper , we present an approach to rapidly creating pixel-accurate semantic label maps for images extracted from modern computer games .
result: The candidate relations for this text are:
Used_for
Used_for
The candidate entities for this text are:
approach
semantic label maps
computer games
images

triple_list: [["approach", "Used_for", "semantic label maps"], ["computer games", "Used_for", "images"]]
pred: [('approach', 'Used_for', 'semantic label maps'), ('computer games', 'Used_for', 'images')]
trues: [['approach', 'Used_for', 'pixel-accurate semantic label maps'], ['pixel-accurate semantic label maps', 'Used_for', 'images'], ['images', 'Part_of', 'modern computer games']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14086471408647142, 0.11744186046511627, 0.12809131261889664]
text: We show that combining anisotropic meshing with a non-quadratic approach to regularization enables us to obtain satisfactory reconstruction results using triangulations with few vertices .
result: triple_list: [["anisotropic meshing", "Conjunction", "non-quadratic approach to regularization"], ["regularization", "Used_for", "reconstruction results"], ["triangulations", "Used_for", "reconstruction results"], ["triangulations", "Compare", "quadrilateral approximations"]]
pred: [('anisotropic meshing', 'Conjunction', 'non-quadratic approach to regularization'), ('regularization', 'Used_for', 'reconstruction results'), ('triangulations', 'Used_for', 'reconstruction results'), ('triangulations', 'Compare', 'quadrilateral approximations')]
trues: [['anisotropic meshing', 'Conjunction', 'non-quadratic approach'], ['anisotropic meshing', 'Used_for', 'reconstruction'], ['non-quadratic approach', 'Used_for', 'regularization'], ['non-quadratic approach', 'Used_for', 'reconstruction'], ['triangulations', 'Used_for', 'reconstruction']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14008321775312066, 0.11676300578034682, 0.1273644388398487]
text: This distribution has numerous applications in computer Go , including serving as an efficient stand-alone Go player .
result: triple_list: [["distribution", "Part_of", "computer Go"], ["Go player", "Used_for", "stand-alone Go player"]]
pred: [('distribution', 'Part_of', 'computer Go'), ('Go player', 'Used_for', 'stand-alone Go player')]
trues: [['distribution', 'Used_for', 'computer Go']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1396957123098202, 0.11662817551963048, 0.12712397734424166]
text: In general , our CRF model yields a lower error rate than the HMM and Max-ent models on the NIST sentence boundary detection task in speech , although it is interesting to note that the best results are achieved by three-way voting among the classifiers .
result: triple_list: [["CRF model", "Evaluate_for", "NIST sentence boundary detection task in speech"], ["HMM and Max-ent models", "Compare", "CRF model"], ["HMM and Max-ent models", "Evaluate_for", "NIST sentence boundary detection task in speech"], ["classifiers", "Evaluate_for", "CRF model"], ["classifiers", "Conjunction", "HMM and Max-ent models"]]
pred: [('CRF model', 'Evaluate_for', 'NIST sentence boundary detection task in speech'), ('HMM and Max-ent models', 'Compare', 'CRF model'), ('HMM and Max-ent models', 'Evaluate_for', 'NIST sentence boundary detection task in speech'), ('classifiers', 'Evaluate_for', 'CRF model'), ('classifiers', 'Conjunction', 'HMM and Max-ent models')]
trues: [['CRF model', 'Compare', 'HMM and Max-ent models'], ['error rate', 'Evaluate_for', 'CRF model'], ['error rate', 'Evaluate_for', 'HMM and Max-ent models'], ['NIST sentence boundary detection task', 'Evaluate_for', 'CRF model'], ['NIST sentence boundary detection task', 'Evaluate_for', 'HMM and Max-ent models'], ['speech', 'Feature_of', 'NIST sentence boundary detection task'], ['classifiers', 'Used_for', 'three-way voting']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13873626373626374, 0.1156930126002291, 0.12617114303560278]
text: One remarkable feature of this model is that it has allowed us to derive an efficient algorithm based on powerful statistical methods for estimating the Fujisaki-model parameters from raw F0 contours .
result: triple_list: [["algorithm", "Used_for", "statistical methods"]]
pred: [('algorithm', 'Used_for', 'statistical methods')]
trues: [['remarkable feature', 'Feature_of', 'model'], ['algorithm', 'Used_for', 'Fujisaki-model parameters'], ['statistical methods', 'Used_for', 'algorithm'], ['raw F0 contours', 'Used_for', 'Fujisaki-model parameters']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13854595336076816, 0.11516533637400228, 0.12577833125778332]
text: Our approach is among the first to propose a generative proba-bilistic framework for 3D object categorization .
result: triple_list: [["approach", "Used_for", "generative proba-bilistic framework for 3D object categorization"]]
pred: [('approach', 'Used_for', 'generative proba-bilistic framework for 3D object categorization')]
trues: [['generative proba-bilistic framework', 'Used_for', '3D object categorization']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13835616438356163, 0.11503416856492027, 0.12562189054726366]
text: In this paper , we introduce an annotation scheme for scientific articles which can be used to build such a resource in a consistent way .
result: triple_list: [["annotation scheme", "Used_for", "scientific articles"]]
pred: [('annotation scheme', 'Used_for', 'scientific articles')]
trues: [['annotation scheme', 'Used_for', 'scientific articles'], ['annotation scheme', 'Used_for', 'resource']]
metrics_sample: [1.0, 0.5, 0.6666666666666666]
metrics_current: [0.13953488372093023, 0.1159090909090909, 0.1266294227188082]
text: From this point of view , selecting suitable positive ( i.e. intra-class ) training samples within a local range is critical for training the CNN embedding , especially when the data has large intra-class variations .
result: triple_list: [["positive ( i.e. intra-class ) training samples", "Feature_of", "CNN embedding"], ["positive ( i.e. intra-class ) training samples", "Used_for", "CNN embedding"], ["data", "Feature_of", "intra-class variations"]]
pred: [('positive ( i.e. intra-class ) training samples', 'Feature_of', 'CNN embedding'), ('positive ( i.e. intra-class ) training samples', 'Used_for', 'CNN embedding'), ('data', 'Feature_of', 'intra-class variations')]
trues: [['intra-class variations', 'Feature_of', 'data']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13896457765667575, 0.11577752553916004, 0.12631578947368421]
text: This paper examines the benefits of system combination for unsupervised WSD .
result: triple_list: [["unsupervised WSD", "Used_for", "system combination"]]
pred: [('unsupervised WSD', 'Used_for', 'system combination')]
trues: [['system combination', 'Used_for', 'unsupervised WSD']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13877551020408163, 0.11564625850340136, 0.12615955473098328]
text: We investigate and analyze the layers of various CNN models and extensively compare between them with the goal of discovering how the layers of distributed representations within CNNs represent object pose information and how this contradicts with object category representations .
result: triple_list: [["layers", "Evaluate_for", "CNN models"], ["layers", "Compare", "them"], ["goal", "Used_for", "layers of distributed representations"], ["distributed representations", "Evaluate_for", "object pose information"], ["distributed representations", "Compare", "object category representations"]]
pred: [('layers', 'Evaluate_for', 'CNN models'), ('layers', 'Compare', 'them'), ('goal', 'Used_for', 'layers of distributed representations'), ('distributed representations', 'Evaluate_for', 'object pose information'), ('distributed representations', 'Compare', 'object category representations')]
trues: [['layers', 'Part_of', 'CNN models'], ['layers of distributed representations', 'Part_of', 'CNNs'], ['layers of distributed representations', 'Used_for', 'object pose information'], ['this', 'Compare', 'object category representations']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13783783783783785, 0.11512415349887133, 0.12546125461254612]
text: We evaluate the quality of the extracted data by showing that it improves the performance of a state-of-the-art statistical machine translation system .
result: triple_list: [["data", "Evaluate_for", "quality"], ["state-of-the-art statistical machine translation system", "Compare", "it"]]
pred: [('data', 'Evaluate_for', 'quality'), ('state-of-the-art statistical machine translation system', 'Compare', 'it')]
trues: [['it', 'Used_for', 'statistical machine translation system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13746630727762804, 0.11499436302142052, 0.1252302025782689]
text: In this situation , the general method is to segment the raw corpus automatically using a word list , correct the output sentences by hand , and build a model from the segmented corpus .
result: triple_list: [["word list", "Used_for", "segmented corpus"], ["segmented corpus", "Part_of", "model"]]
pred: [('word list', 'Used_for', 'segmented corpus'), ('segmented corpus', 'Part_of', 'model')]
trues: [['method', 'Used_for', 'raw corpus'], ['word list', 'Used_for', 'method'], ['segmented corpus', 'Used_for', 'model']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13709677419354838, 0.1146067415730337, 0.12484700122399021]
text: We propose a corpus-based method ( Biber ,1993 ; Nagao ,1993 ; Smadja ,1993 ) which generates Noun Classifier Associations ( NCA ) to overcome the problems in classifier assignment and semantic construction of noun phrase .
result: triple_list: [["corpus-based method", "Used_for", "Noun Classifier Associations ( NCA )"], ["Noun Classifier Associations ( NCA )", "Conjunction", "classifier assignment"], ["classifier assignment", "Feature_of", "Noun phrase"], ["semantic construction", "Conjunction", "Noun phrase"], ["semantic construction", "Feature_of", "Noun phrase"]]
pred: [('corpus-based method', 'Used_for', 'Noun Classifier Associations ( NCA )'), ('Noun Classifier Associations ( NCA )', 'Conjunction', 'classifier assignment'), ('classifier assignment', 'Feature_of', 'Noun phrase'), ('semantic construction', 'Conjunction', 'Noun phrase'), ('semantic construction', 'Feature_of', 'Noun phrase')]
trues: [['corpus-based method', 'Used_for', 'Noun Classifier Associations ( NCA )'], ['corpus-based method', 'Used_for', 'classifier assignment'], ['corpus-based method', 'Used_for', 'semantic construction of noun phrase'], ['Noun Classifier Associations ( NCA )', 'Used_for', 'classifier assignment'], ['Noun Classifier Associations ( NCA )', 'Used_for', 'semantic construction of noun phrase'], ['classifier assignment', 'Conjunction', 'semantic construction of noun phrase']]
metrics_sample: [0.2, 0.16666666666666666, 0.1818181818181818]
metrics_current: [0.1375166889185581, 0.11495535714285714, 0.1252279635258359]
text: Experimental results on our dataset and the public G3D dataset both demonstrate very promising performance of our scheme .
result: triple_list: [["dataset", "Used_for", "scheme"], ["G3D dataset", "Compare", "dataset"]]
pred: [('dataset', 'Used_for', 'scheme'), ('G3D dataset', 'Compare', 'dataset')]
trues: [['dataset', 'Conjunction', 'G3D dataset']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13715046604527298, 0.11482720178372352, 0.125]
text: These models simulate the reading time advantage for parallel structures found in human data , and also yield a small increase in overall parsing accuracy .
result: triple_list: [["models", "Used_for", "reading time advantage for parallel structures"], ["human data", "Feature_of", "models"], ["models", "Used_for", "parsing accuracy"], ["overall parsing accuracy", "Compare", "parsing accuracy"]]
pred: [('models', 'Used_for', 'reading time advantage for parallel structures'), ('human data', 'Feature_of', 'models'), ('models', 'Used_for', 'parsing accuracy'), ('overall parsing accuracy', 'Compare', 'parsing accuracy')]
trues: [['parallel structures', 'Part_of', 'human data']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13642384105960265, 0.11469933184855234, 0.12462189957652753]
text: The two main contributions of this paper are : i ) a new type of three-plane graph for dense-stereo dynamic-programming , that encourages correct occlusion labeling ; ii ) a compact geometric derivation for novel-view synthesis by direct projection of the minimum-cost surface .
result: triple_list: [["three-plane graph", "Used_for", "dense-stereo dynamic-programming"], ["occlusion labeling", "Evaluate_for", "three-plane graph"], ["geometric derivation", "Used_for", "novel-view synthesis"], ["direct projection", "Used_for", "geometric derivation"], ["minimum-cost surface", "Used_for", "novel-view synthesis"]]
pred: [('three-plane graph', 'Used_for', 'dense-stereo dynamic-programming'), ('occlusion labeling', 'Evaluate_for', 'three-plane graph'), ('geometric derivation', 'Used_for', 'novel-view synthesis'), ('direct projection', 'Used_for', 'geometric derivation'), ('minimum-cost surface', 'Used_for', 'novel-view synthesis')]
trues: [['three-plane graph', 'Used_for', 'dense-stereo dynamic-programming'], ['dense-stereo dynamic-programming', 'Used_for', 'occlusion labeling'], ['compact geometric derivation', 'Used_for', 'novel-view synthesis'], ['direct projection of the minimum-cost surface', 'Used_for', 'compact geometric derivation']]
metrics_sample: [0.2, 0.25, 0.22222222222222224]
metrics_current: [0.1368421052631579, 0.11529933481152993, 0.12515042117930203]
text: Evaluation on the ACE 2003 corpus shows that the convolution kernel over parse trees can achieve comparable performance with the previous best-reported feature-based methods on the 24 ACE relation subtypes .
result: triple_list: [["ACE 2003 corpus", "Evaluate_for", "convolution kernel over parse trees"], ["ACE 2003 corpus", "Used_for", "performance"], ["feature-based methods", "Compare", "convolution kernel over parse trees"], ["24 ACE relation subtypes", "Hyponym_of", "ACE 2003 corpus"]]
pred: [('ACE 2003 corpus', 'Evaluate_for', 'convolution kernel over parse trees'), ('ACE 2003 corpus', 'Used_for', 'performance'), ('feature-based methods', 'Compare', 'convolution kernel over parse trees'), ('24 ACE relation subtypes', 'Hyponym_of', 'ACE 2003 corpus')]
trues: [['ACE 2003 corpus', 'Evaluate_for', 'convolution kernel over parse trees'], ['feature-based methods', 'Compare', 'convolution kernel over parse trees']]
metrics_sample: [0.5, 1.0, 0.6666666666666666]
metrics_current: [0.1387434554973822, 0.1172566371681416, 0.12709832134292565]
text: Computing power per area and power consumption is amongst the highest reported for a single chip .
result: triple_list: [["Computing power per area", "Compare", "power consumption"], ["chip", "Compare", "Computing power per area"], ["chip", "Evaluate_for", "power consumption"]]
pred: [('Computing power per area', 'Compare', 'power consumption'), ('chip', 'Compare', 'Computing power per area'), ('chip', 'Evaluate_for', 'power consumption')]
trues: [['Computing power per area', 'Conjunction', 'power consumption']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13820078226857888, 0.11712707182320442, 0.12679425837320576]
text: First , we investigate how well the addressee of a dialogue act can be predicted based on gaze , utterance and conversational context features .
result: triple_list: [["addressee of a dialogue act", "Used_for", "gaze , utterance and conversational context features"]]
pred: [('addressee of a dialogue act', 'Used_for', 'gaze , utterance and conversational context features')]
trues: [['gaze', 'Used_for', 'addressee of a dialogue act'], ['gaze', 'Conjunction', 'utterance'], ['utterance', 'Used_for', 'addressee of a dialogue act'], ['utterance', 'Conjunction', 'conversational context features'], ['conversational context features', 'Used_for', 'addressee of a dialogue act']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13802083333333334, 0.11648351648351649, 0.1263408820023838]
text: First , it uses several kinds of dictionaries to segment and tag Japanese character strings .
result: triple_list: [["dictionaries", "Used_for", "segment and tag Japanese character strings"]]
pred: [('dictionaries', 'Used_for', 'segment and tag Japanese character strings')]
trues: [['dictionaries', 'Used_for', 'it'], ['dictionaries', 'Used_for', 'Japanese character strings']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1378413524057217, 0.1162280701754386, 0.12611540749553837]
text: A demonstration ( in UNIX ) for Applied Natural Language Processing emphasizes components put to novel technical uses in intelligent computer-assisted morphological analysis ( ICALL ) , including disambiguated morphological analysis and lemmatized indexing for an aligned bilingual corpus of word examples .
result: triple_list: [["UNIX", "Used_for", "Applied Natural Language Processing"]]
pred: [('UNIX', 'Used_for', 'Applied Natural Language Processing')]
trues: [['components', 'Used_for', 'intelligent computer-assisted morphological analysis ( ICALL )'], ['disambiguated morphological analysis', 'Hyponym_of', 'components'], ['disambiguated morphological analysis', 'Conjunction', 'lemmatized indexing'], ['disambiguated morphological analysis', 'Used_for', 'aligned bilingual corpus'], ['lemmatized indexing', 'Hyponym_of', 'components'], ['lemmatized indexing', 'Used_for', 'aligned bilingual corpus']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13766233766233765, 0.11546840958605664, 0.12559241706161137]
text: The experiments show that the system is able to detect scf types with 70 % precision and 66 % recall rate .
result: triple_list: [["scf types", "Evaluate_for", "system"], ["precision", "Compare", "recall rate"]]
pred: [('scf types', 'Evaluate_for', 'system'), ('precision', 'Compare', 'recall rate')]
trues: [['precision', 'Evaluate_for', 'system'], ['precision', 'Conjunction', 'recall'], ['recall', 'Evaluate_for', 'system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13730569948186527, 0.11509229098805646, 0.12522150029533372]
text: In addition , we conduct synthetic experiments as well as a real application on noisy image classification to show that our method also improves the performance in practice by exploiting side information .
result: triple_list: [["method", "Used_for", "side information"], ["synthetic experiments", "Evaluate_for", "method"], ["real application", "Evaluate_for", "method"], ["noisy image classification", "Evaluate_for", "method"]]
pred: [('method', 'Used_for', 'side information'), ('synthetic experiments', 'Evaluate_for', 'method'), ('real application', 'Evaluate_for', 'method'), ('noisy image classification', 'Evaluate_for', 'method')]
trues: [['noisy image classification', 'Evaluate_for', 'method'], ['side information', 'Used_for', 'method']]
metrics_sample: [0.25, 0.5, 0.3333333333333333]
metrics_current: [0.13788659793814434, 0.11592632719393282, 0.125956444967628]
text: Our method takes advantage of the different way in which word senses are lexicalised in English and Chinese , and also exploits the large amount of Chinese text available in corpora and on the Web .
result: triple_list: [["method", "Used_for", "word senses"]]
pred: [('method', 'Used_for', 'word senses')]
trues: [['Chinese text', 'Part_of', 'corpora'], ['Chinese text', 'Part_of', 'Web'], ['corpora', 'Conjunction', 'Web']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1377091377091377, 0.11555075593952484, 0.1256605989430417]
text: This paper gives an overall account of a prototype natural language question answering system , called Chat-80 .
result: triple_list: [["natural language question answering system", "Conjunction", "prototype natural language question answering system"], ["prototype natural language question answering system", "Hyponym_of", "Chat-80"]]
pred: [('natural language question answering system', 'Conjunction', 'prototype natural language question answering system'), ('prototype natural language question answering system', 'Hyponym_of', 'Chat-80')]
trues: [['Chat-80', 'Hyponym_of', 'natural language question answering system']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13735558408215662, 0.11542610571736785, 0.1254396248534584]
text: The modified graph is then sent to the UNL-L0 deconverter and the result shown .
result: triple_list: [["graph", "Used_for", "UNL-L0 deconverter"]]
pred: [('graph', 'Used_for', 'UNL-L0 deconverter')]
trues: [['graph', 'Used_for', 'UNL-L0 deconverter']]
metrics_sample: [1.0, 1.0, 1.0]
metrics_current: [0.13846153846153847, 0.11637931034482758, 0.12646370023419204]
text: Specifically , we show how to incorporate a simple prior on the distribution of natural images into support vector machines .
result: triple_list: [["prior", "Feature_of", "distribution of natural images"]]
pred: [('prior', 'Feature_of', 'distribution of natural images')]
trues: [['prior on the distribution of natural images', 'Used_for', 'support vector machines']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1382842509603073, 0.116254036598493, 0.12631578947368421]
text: In this paper we present a new UV procedure with two major features : a ) Confidence tests are applied to decoded string hypotheses obtained from using word and garbage models that represent OOV words and noises .
result: triple_list: [["Confidence tests", "Feature_of", "UV procedure"], ["features", "Used_for", "UV procedure"]]
pred: [('Confidence tests', 'Feature_of', 'UV procedure'), ('features', 'Used_for', 'UV procedure')]
trues: [['Confidence tests', 'Used_for', 'decoded string hypotheses'], ['noises', 'Conjunction', 'OOV words']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13793103448275862, 0.11600429645542427, 0.12602100350058346]
text: We demonstrate our approach with multiple PTZ camera sequences in typical outdoor surveillance settings and show a comparison with state-of-the-art approaches .
result: triple_list: [["multiple PTZ camera sequences", "Used_for", "approach"], ["PTZ camera sequences", "Compare", "state-of-the-art approaches"]]
pred: [('multiple PTZ camera sequences', 'Used_for', 'approach'), ('PTZ camera sequences', 'Compare', 'state-of-the-art approaches')]
trues: [['approach', 'Used_for', 'outdoor surveillance settings'], ['approach', 'Compare', 'state-of-the-art approaches'], ['multiple PTZ camera sequences', 'Used_for', 'approach']]
metrics_sample: [0.5, 0.3333333333333333, 0.4]
metrics_current: [0.13885350318471337, 0.11670235546038545, 0.1268179173938336]
text: The results show that the features in terms of which we formulate our heuristic principles have significant predictive power , and that rules that closely resemble our Horn clauses can be learnt automatically from these features .
result: triple_list: [["features", "Conjunction", "Horn clauses"], ["features", "Used_for", "predictive power"], ["predictive power", "Used_for", "rules"]]
pred: [('features', 'Conjunction', 'Horn clauses'), ('features', 'Used_for', 'predictive power'), ('predictive power', 'Used_for', 'rules')]
trues: [['features', 'Feature_of', 'heuristic principles']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1383248730964467, 0.11657754010695187, 0.126523505513639]
text: We further demonstrate synthesis from a freely translating virtual camera .
result: triple_list: [["freely translating virtual camera", "Used_for", "synthesis"]]
pred: [('freely translating virtual camera', 'Used_for', 'synthesis')]
trues: [['translating virtual camera', 'Used_for', 'synthesis']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13814955640050697, 0.11645299145299146, 0.1263768115942029]
text: This paper proposes a generic mathematical formalism for the combination of various structures : strings , trees , dags , graphs , and products of them .
result: triple_list: [["structures", "Conjunction", "strings"], ["structures", "Conjunction", "trees"], ["structures", "Conjunction", "dags"], ["structures", "Conjunction", "graphs"], ["structures", "Conjunction", "products of them"]]
pred: [('structures', 'Conjunction', 'strings'), ('structures', 'Conjunction', 'trees'), ('structures', 'Conjunction', 'dags'), ('structures', 'Conjunction', 'graphs'), ('structures', 'Conjunction', 'products of them')]
trues: [['strings', 'Hyponym_of', 'structures'], ['strings', 'Conjunction', 'trees'], ['trees', 'Hyponym_of', 'structures'], ['trees', 'Conjunction', 'dags'], ['dags', 'Hyponym_of', 'structures'], ['dags', 'Conjunction', 'graphs'], ['graphs', 'Hyponym_of', 'structures']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13727959697732997, 0.11558854718981973, 0.12550374208405296]
text: A central goal of this research is to merge approaches from pivot MT , interactive MT , and multilingual text authoring .
result: The candidate relations for this text are:
Used_for
Conjunction
Used_for
Conjunction
Used_for
The candidate entities for this text are:
pivot MT
interactive MT
pivot MT
multilingual text authoring
interactive MT
multilingual text authoring
multilingual text authoring
pivot MT
interactive MT

triple_list: [["pivot MT", "Used_for", "interactive MT"], ["pivot MT", "Conjunction", "multilingual text authoring"], ["interactive MT", "Used_for", "multilingual text authoring"], ["multilingual text authoring", "Conjunction", "pivot MT"], ["interactive MT", "Used_for", "pivot MT"]]
pred: [('pivot MT', 'Used_for', 'interactive MT'), ('pivot MT', 'Conjunction', 'multilingual text authoring'), ('interactive MT', 'Used_for', 'multilingual text authoring'), ('multilingual text authoring', 'Conjunction', 'pivot MT'), ('interactive MT', 'Used_for', 'pivot MT')]
trues: [['pivot MT', 'Conjunction', 'interactive MT'], ['interactive MT', 'Conjunction', 'multilingual text authoring']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13642052565707133, 0.11534391534391535, 0.125]
text: In this paper , we present an unlexicalized parser for German which employs smoothing and suffix analysis to achieve a labelled bracket F-score of 76.2 , higher than previously reported results on the NEGRA corpus .
result: triple_list: [["unlexicalized parser", "Conjunction", "smoothing"], ["smoothing", "Feature_of", "unlexicalized parser"], ["German", "Used_for", "unlexicalized parser"], ["smoothing", "Hyponym_of", "smoothing"], ["smoothing", "Conjunction", "suffix analysis"], ["suffix analysis", "Hyponym_of", "smoothing"], ["smoothi

pred: [('unlexicalized parser', 'Conjunction', 'smoothing'), ('smoothing', 'Feature_of', 'unlexicalized parser'), ('German', 'Used_for', 'unlexicalized parser'), ('smoothing', 'Hyponym_of', 'smoothing'), ('smoothing', 'Conjunction', 'suffix analysis'), ('suffix analysis', 'Hyponym_of', 'smoothing')]
trues: [['unlexicalized parser', 'Used_for', 'German'], ['smoothing', 'Used_for', 'unlexicalized parser'], ['smoothing', 'Conjunction', 'suffix analysis'], ['suffix analysis', 'Used_for', 'unlexicalized parser'], ['labelled bracket F-score', 'Evaluate_for', 'unlexicalized parser'], ['NEGRA corpus', 'Evaluate_for', 'unlexicalized parser']]
metrics_sample: [0.16666666666666666, 0.16666666666666666, 0.16666666666666666]
metrics_current: [0.13664596273291926, 0.1156677181913775, 0.1252847380410023]
text: We also found that OA is crucial for auditory processing by onset neurons ( ONs ) in the next neuronal stage , the auditory brainstem .
result: triple_list: [["OA", "Conjunction", "onset neurons ( ONs ) in the next neuronal stage , the auditory brainstem"]]
pred: [('OA', 'Conjunction', 'onset neurons ( ONs ) in the next neuronal stage , the auditory brainstem')]
trues: [['OA', 'Used_for', 'auditory processing'], ['onset neurons ( ONs )', 'Used_for', 'OA']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13647642679900746, 0.11542497376705142, 0.1250710631040364]
text: Based on these results , we present an ECA that uses verbal and nonverbal grounding acts to update dialogue state .
result: triple_list: [["ECA", "Used_for", "dialogue state"]]
pred: [('ECA', 'Used_for', 'dialogue state')]
trues: [['verbal and nonverbal grounding acts', 'Used_for', 'ECA'], ['verbal and nonverbal grounding acts', 'Used_for', 'dialogue state']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13630731102850063, 0.11518324607329843, 0.12485811577752554]
text: Experimental results from a real telephone application on a natural number recognition task show an 50 % reduction in recognition errors with a moderate 12 % rejection rate of correct utterances and a low 1.5 % rate of false acceptance .
result: triple_list: [["natural number recognition task", "Feature_of", "telephone application"], ["recognition errors", "Evaluate_for", "natural number recognition task"], ["recognition errors", "Compare", "rejection rate"], ["correct utterances", "Conjunction", "rejection rate"], ["low 1.5 % rate", "Compare", "rate of false acceptance"]]
pred: [('natural number recognition task', 'Feature_of', 'telephone application'), ('recognition errors', 'Evaluate_for', 'natural number recognition task'), ('recognition errors', 'Compare', 'rejection rate'), ('correct utterances', 'Conjunction', 'rejection rate'), ('low 1.5 % rate', 'Compare', 'rate of false acceptance')]
trues: [['natural number recognition task', 'Feature_of', 'telephone application'], ['recognition errors', 'Evaluate_for', 'natural number recognition task']]
metrics_sample: [0.4, 1.0, 0.5714285714285715]
metrics_current: [0.13793103448275862, 0.11703239289446186, 0.12662521198417184]
text: This paper deals with the problem of generating the fundamental frequency ( F0 ) contour of speech from a text input for text-to-speech synthesis .
result: triple_list: [["text input", "Used_for", "fundamental frequency ( F0 ) contour of speech"], ["text-to-speech synthesis", "Used_for", "fundamental frequency ( F0 ) contour of speech"]]
pred: [('text input', 'Used_for', 'fundamental frequency ( F0 ) contour of speech'), ('text-to-speech synthesis', 'Used_for', 'fundamental frequency ( F0 ) contour of speech')]
trues: [['fundamental frequency ( F0 ) contour of speech', 'Used_for', 'text-to-speech synthesis'], ['text input', 'Used_for', 'fundamental frequency ( F0 ) contour of speech']]
metrics_sample: [0.5, 0.5, 0.5]
metrics_current: [0.13882063882063883, 0.11783107403545359, 0.12746756909193457]
text: We describe how to estimate these indicators and how to integrate them into a retrieval approach based on language models .
result: triple_list: [["indicators", "Evaluate_for", "retrieval approach"], ["language models", "Used_for", "retrieval approach"]]
pred: [('indicators', 'Evaluate_for', 'retrieval approach'), ('language models', 'Used_for', 'retrieval approach')]
trues: [['them', 'Part_of', 'retrieval approach'], ['language models', 'Used_for', 'them']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.13848039215686275, 0.11758584807492195, 0.12718064153066966]
text: We propose a multi-task end-to-end Joint Classification-Regression Recurrent Neural Network to better explore the action type and temporal localiza-tion information .
result: triple_list: [["multi-task end-to-end Joint Classification-Regression Recurrent Neural Network", "Used_for", "action type"], ["multi-task end-to-end Joint Classification-Regression Recurrent Neural Network", "Used_for", "temporal localiza-tion information"]]
pred: [('multi-task end-to-end Joint Classification-Regression Recurrent Neural Network', 'Used_for', 'action type'), ('multi-task end-to-end Joint Classification-Regression Recurrent Neural Network', 'Used_for', 'temporal localiza-tion information')]
trues: [['multi-task end-to-end Joint Classification-Regression Recurrent Neural Network', 'Used_for', 'action type'], ['multi-task end-to-end Joint Classification-Regression Recurrent Neural Network', 'Used_for', 'temporal localiza-tion information'], ['action type', 'Conjunction', 'temporal localiza-tion information']]
metrics_sample: [1.0, 0.6666666666666666, 0.8]
metrics_current: [0.14058679706601468, 0.11929460580912864, 0.12906846240179576]
text: Experiment results on ACE corpora show that this spectral clustering based approach outperforms the other clustering methods .
result: triple_list: [["ACE corpora", "Evaluate_for", "spectral clustering based approach"], ["clustering methods", "Compare", "spectral clustering based approach"]]
pred: [('ACE corpora', 'Evaluate_for', 'spectral clustering based approach'), ('clustering methods', 'Compare', 'spectral clustering based approach')]
trues: [['ACE corpora', 'Evaluate_for', 'spectral clustering based approach'], ['ACE corpora', 'Evaluate_for', 'clustering methods'], ['spectral clustering based approach', 'Compare', 'clustering methods']]
metrics_sample: [0.5, 0.3333333333333333, 0.4]
metrics_current: [0.14146341463414633, 0.11995863495346432, 0.12982652490207053]
text: Our goal is to learn a Mahalanobis distance by minimizing a loss defined on the weighted sum of the precision at different ranks .
result: triple_list: [["Mahalanobis distance", "Used_for", "loss"]]
pred: [('Mahalanobis distance', 'Used_for', 'loss')]
trues: [['loss', 'Used_for', 'Mahalanobis distance'], ['weighted sum', 'Feature_of', 'precision']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14129110840438489, 0.1197110423116615, 0.12960893854748604]
text: With relevant approach , we identify important contents by PageRank algorithm on the event map constructed from documents .
result: triple_list: [["PageRank algorithm", "Used_for", "contents"]]
pred: [('PageRank algorithm', 'Used_for', 'contents')]
trues: [['PageRank algorithm', 'Used_for', 'relevant approach'], ['event map', 'Used_for', 'PageRank algorithm'], ['documents', 'Used_for', 'event map']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.1411192214111922, 0.11934156378600823, 0.1293199554069119]
text: An important area of learning in autonomous agents is the ability to learn domain-speciic models of actions to be used by planning systems .
result: triple_list: [["domain-speciic models of actions", "Used_for", "planning systems"]]
pred: [('domain-speciic models of actions', 'Used_for', 'planning systems')]
trues: [['learning in autonomous agents', 'Used_for', 'domain-speciic models of actions'], ['planning systems', 'Used_for', 'domain-speciic models of actions']]
metrics_sample: [0.0, 0.0, 0]
metrics_current: [0.14094775212636695, 0.11909650924024641, 0.12910406232609906]